{"title":"Sql优化方法","uid":"1796052fe66afe402255c3eb4319b228","slug":"Sql优化方法","date":"2024-11-21T00:00:00.000Z","updated":"2024-12-24T01:56:35.264Z","comments":true,"path":"api/articles/Sql优化方法.json","keywords":null,"cover":"https://github.com/faceman0814/picx-images-hosting/raw/master/20241120/image.esjgf1zs0.webp","content":"<p>最近新入职了一家电商公司，做CRM系统，由于业务量比较大，数据量庞大动不动几十万数据起步，数据库的压力也很大。比如最近遇到的需求，需要查看最规定时间内客户是否有下单，或者是否有跟客户联系，如果没有的话就要释放出去，这就需要去订单表查询他的下单记录和联系记录。联系记录好查，有定时同步最后一次联系时间的，但订单表的数据量大，要查询所有用户的最后一单成交记录就需要分组去查了。我直接写在linq里面查询，速度贼慢，查询了几分钟，还没返回结果。但是我把查询订单这一步单独拿出来做成视图再去连表查询，速度就快多了几秒就出来了。<br>查了下大概原因应该是视图在数据库中被预先编译和优化，所以当通过视图查询数据时，数据库可以快速响应。而直接在EF Core中使用LINQ查询可能会生成不够优化的SQL语句，尤其是涉及到聚合、分组等操作时。所以数据量大且查询性能不好时，也不失为一种优化方法（如果有误请指正）。</p>\n<p>以前数据量小没怎么关注过Sql优化，所以下面记录一些常用的Sql优化方法，以mysql为例。</p>\n<h2 id=\"1-避免使用select\"><a href=\"#1-避免使用select\" class=\"headerlink\" title=\"1. 避免使用select *\"></a>1. 避免使用select *</h2><p>很多时候，我们写sql语句时，为了方便，喜欢直接使用select *，一次性查出表中所有列的数据。在实际业务场景中，可能我们真正需要使用的只有其中一两列。查了很多数据，但是不用，白白浪费了数据库资源，比如：内存或者cpu。此外，多查出来的数据，通过网络IO传输的过程中，也会增加数据传输的时间。还有一个最重要的问题是：select *不会走覆盖索引，会出现大量的回表操作，而从导致查询sql的性能很低。</p>\n<p>所以，最佳实践是：只选择需要的列，并且尽量避免使用select *。</p>\n<h2 id=\"2-用union-all代替union\"><a href=\"#2-用union-all代替union\" class=\"headerlink\" title=\"2. 用union all代替union\"></a>2. 用union all代替union</h2><p>union all不会去重，而union会，排重的过程需要遍历、排序和比较，它更耗时，更消耗cpu资源。所以需要去重用union不需要去重的时候用union all。</p>\n<h2 id=\"3-小表驱动大表\"><a href=\"#3-小表驱动大表\" class=\"headerlink\" title=\"3. 小表驱动大表\"></a>3. 小表驱动大表</h2><p>如果sql语句中包含了in关键字，则它会优先执行in里面的子查询语句，然后再执行in外面的语句。如果in里面的数据量很少，作为条件查询速度更快。<br>而如果sql语句中包含了exists关键字，它优先执行exists左边的语句（即主查询语句）。然后把它作为条件，去跟右边的语句匹配。如果匹配上，则可以查询出数据。如果匹配不上，数据就被过滤掉了。</p>\n<ul>\n<li>in 适用于左边大表，右边小表。</li>\n<li>exists 适用于左边小表，右边大表。<br>不管是用in，还是exists关键字，其核心思想都是用小表驱动大表。</li>\n</ul>\n<h2 id=\"4-批量插入\"><a href=\"#4-批量插入\" class=\"headerlink\" title=\"4. 批量插入\"></a>4. 批量插入</h2><p>批量插入可以提高数据库的插入性能。我们可以把需要插入的数据分批次插入，而不是一条一条插入。这样可以减少网络IO，提高数据库的插入性能。<br>但需要注意的是，不建议一次批量操作太多的数据，如果数据太多数据库响应也会很慢。批量操作需要把握一个度，建议每批数据尽量控制在500以内。如果数据多于500，则分多批次处理。</p>\n<h2 id=\"5-多用limit\"><a href=\"#5-多用limit\" class=\"headerlink\" title=\"5. 多用limit\"></a>5. 多用limit</h2><p>limit可以限制查询结果的数量，避免查询出大量数据，影响查询效率。<br>比如查询某个用户下的第一个订单，想看看他第一次的首单时间。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT order_time FROM orders WHERE user_id = 1 ORDER BY order_time LIMIT 1;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-in中值太多\"><a href=\"#6-in中值太多\" class=\"headerlink\" title=\"6. in中值太多\"></a>6. in中值太多</h2><p>in中值太多，会导致查询计划变得复杂，索引失效，导致查询效率变低。所以in中值不要太多。</p>\n<p>对于批量查询接口，我们通常会使用in关键字过滤出数据。比如：想通过指定的一些id，批量查询出用户信息，但是如果我们不做任何限制，该查询语句一次性可能会查询出非常多的数据，很容易导致接口超时。所以可以在sql中对数据用limit做限制。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM user_info WHERE id IN (1,2,3,4,5,6,7,8,9,10) LIMIT 10;</span><br></pre></td></tr></table></figure>\n\n<p>还有一个方案就是：如果ids超过500条记录，可以分批用多线程去查询数据。每批只查500条记录，最后把查询到的数据汇总到一起返回。</p>\n<h2 id=\"7-增量查询\"><a href=\"#7-增量查询\" class=\"headerlink\" title=\"7. 增量查询\"></a>7. 增量查询</h2><p>增量查询可以避免全表扫描，只查询新增的数据。<br>比如：我们想查询某个用户的新增订单，只需要查询user_id大于某个值，并且order_time大于某个值的数据。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM orders WHERE user_id &gt; 1000 AND order_time &gt; &#x27;2021-01-01&#x27;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-高效的分页\"><a href=\"#8-高效的分页\" class=\"headerlink\" title=\"8. 高效的分页\"></a>8. 高效的分页</h2><p>分页查询是数据库查询中最常用的功能之一。分页查询可以提高查询效率，避免查询出大量数据，影响查询效率。</p>\n<h3 id=\"方案一-limit\"><a href=\"#方案一-limit\" class=\"headerlink\" title=\"方案一 limit\"></a>方案一 limit</h3><p>在mysql中分页一般用的limit关键字，如果表中数据量少，用limit关键字做分页，没啥问题。但如果表中数据量很多，用它就会出现性能问题。<br>比如现在分页参数变成了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select id,name,age </span><br><span class=\"line\">from user limit 1000000,20;</span><br></pre></td></tr></table></figure>\n\n<p>mysql会查到1000020条数据，然后丢弃前面的1000000条，只查后面的20条数据，这个是非常浪费资源的。<br>那么，这种海量数据该怎么分页呢？<br>优化sql：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select id,name,age </span><br><span class=\"line\">from user where id &gt; 1000000 limit 20;</span><br></pre></td></tr></table></figure>\n\n<p>先找到上次分页最大的id，然后利用id上的索引查询。不过该方案，要求id是连续的，并且有序的。</p>\n<h3 id=\"方案二-between\"><a href=\"#方案二-between\" class=\"headerlink\" title=\"方案二 between\"></a>方案二 between</h3><p>另一种分页方法是利用between关键字，比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select id,name,age </span><br><span class=\"line\">from user where id between 1000000 and 1000020;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是between要在唯一索引上分页，不然会出现每页大小不一致的问题。</p>\n<h2 id=\"9-用连接查询代替子查询\"><a href=\"#9-用连接查询代替子查询\" class=\"headerlink\" title=\"9. 用连接查询代替子查询\"></a>9. 用连接查询代替子查询</h2><p>连接查询是一种更高效的查询方式。连接查询可以避免子查询的性能问题。<br>比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from order</span><br><span class=\"line\">where user_id in (select id from user where status=1)</span><br></pre></td></tr></table></figure>\n\n<p>子查询会导致大量的回表操作，导致查询效率很低。<br>优化sql：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select o.* from order o</span><br><span class=\"line\">inner join user u on o.user_id = u.id</span><br><span class=\"line\">where u.status=1</span><br></pre></td></tr></table></figure>\n\n<p>用连接查询，把子查询结果作为一个表，直接与主表连接，避免了回表操作。</p>\n<h2 id=\"10-提升group-by的效率\"><a href=\"#10-提升group-by的效率\" class=\"headerlink\" title=\"10. 提升group by的效率\"></a>10. 提升group by的效率</h2><p>我们有很多业务场景需要使用group by关键字，它主要的功能是去重和分组。通常它会跟having一起配合使用，表示分组后再根据一定的条件过滤数据。<br>比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select user_id,user_name from order</span><br><span class=\"line\">group by user_id</span><br><span class=\"line\">having user_id &lt;= 200;</span><br></pre></td></tr></table></figure>\n\n<p>这种写法性能不好，它先把所有的订单根据用户id分组之后，再去过滤用户id大于等于200的用户。分组是一个相对耗时的操作，为什么我们不先缩小数据的范围之后，再分组呢？<br>优化sql：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select user_id,user_name from order</span><br><span class=\"line\">where user_id &lt;= 200</span><br><span class=\"line\">group by user_id</span><br></pre></td></tr></table></figure>\n\n<p>使用where条件在分组前，就把多余的数据过滤掉了，这样分组时效率就会更高一些。<br>其实这是一种思路，不仅限于group by的优化。我们的sql语句在做一些耗时的操作之前，应尽可能缩小数据范围，这样能提升sql整体的性能。</p>\n<h2 id=\"11-索引优化\"><a href=\"#11-索引优化\" class=\"headerlink\" title=\"11. 索引优化\"></a>11. 索引优化</h2><p>很多时候sql语句，走了索引，和没有走索引，执行效率差别很大。所以索引优化被作为sql优化的首选。索引优化的第一步是：检查sql语句有没有走索引。那么，如何查看sql走了索引没？可以使用explain命令，查看mysql的执行计划。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">explain select * from user where id = 1;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://github.com/faceman0814/picx-images-hosting/raw/master/20241120/image.8s3c2cr46b.webp\" alt=\"image\"></p>\n<p>sql语句没有走索引，排除没有建索引之外，最大的可能性是索引失效了。</p>\n<p><img src=\"https://github.com/faceman0814/picx-images-hosting/raw/master/20241120/image.5c10a9ik0h.webp\" alt=\"image\"><br>此外，你有没有遇到过这样一种情况：明明是同一条sql，只有入参不同而已。有的时候走的索引a，有的时候却走的索引b？没错，有时候mysql会选错索引。必要时可以使用force index来强制查询sql走某个索引。</p>\n","feature":false,"text":"最近新入职了一家电商公司，做CRM系统，由于业务量比较大，数据量庞大动不动几十万数据起步，数据库的压力也很大。比如最近遇到的需求，需要查看最规定时间内客户是否有...","permalink":"/post/Sql优化方法","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"数据库","slug":"数据库","count":1,"path":"api/categories/数据库.json"}],"tags":[{"name":"Sql","slug":"Sql","count":1,"path":"api/tags/Sql.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8select\"><span class=\"toc-text\">1. 避免使用select *</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%94%A8union-all%E4%BB%A3%E6%9B%BFunion\"><span class=\"toc-text\">2. 用union all代替union</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%B0%8F%E8%A1%A8%E9%A9%B1%E5%8A%A8%E5%A4%A7%E8%A1%A8\"><span class=\"toc-text\">3. 小表驱动大表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5\"><span class=\"toc-text\">4. 批量插入</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%A4%9A%E7%94%A8limit\"><span class=\"toc-text\">5. 多用limit</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-in%E4%B8%AD%E5%80%BC%E5%A4%AA%E5%A4%9A\"><span class=\"toc-text\">6. in中值太多</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-%E5%A2%9E%E9%87%8F%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\">7. 增量查询</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-%E9%AB%98%E6%95%88%E7%9A%84%E5%88%86%E9%A1%B5\"><span class=\"toc-text\">8. 高效的分页</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%A1%88%E4%B8%80-limit\"><span class=\"toc-text\">方案一 limit</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%A1%88%E4%BA%8C-between\"><span class=\"toc-text\">方案二 between</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-%E7%94%A8%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E4%BB%A3%E6%9B%BF%E5%AD%90%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\">9. 用连接查询代替子查询</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-%E6%8F%90%E5%8D%87group-by%E7%9A%84%E6%95%88%E7%8E%87\"><span class=\"toc-text\">10. 提升group by的效率</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">11. 索引优化</span></a></li></ol>","author":{"name":"FaceMan","slug":"blog-author","avatar":"https://github.com/faceman0814/picx-images-hosting/raw/master/20241114/image.2vermeukr5.webp","link":"/","description":"从0开始，直到1。","socials":{"github":"https://github.com/faceman0814","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/manmanzainuli","juejin":"","customs":{"bokeyuan":{"icon":"/svg/bokeyuan.svg","link":"https://www.cnblogs.com/FaceMan"}}}},"mapped":true,"hidden":false,"prev_post":{"title":".NetCore自动开启事务保证数据一致性","uid":"26f6a1758883b55cdee304c67b5f3a44","slug":"NetCore自动开启事务","date":"2024-11-22T00:00:00.000Z","updated":"2024-12-24T01:56:35.264Z","comments":true,"path":"api/articles/NetCore自动开启事务.json","keywords":null,"cover":"https://github.com/faceman0814/picx-images-hosting/raw/master/20241116/image.32hzl5ngkn.webp","text":"起因是因为公司没有使用任何代码框架，所以使用的都是比较原始的写法，在系统的各处都有SaveChanges()方法,这样会产生一个问题就是，如果出现异常前面已经执...","permalink":"/post/NetCore自动开启事务","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":".Net","slug":"Net","count":4,"path":"api/categories/Net.json"}],"tags":[{"name":".NetCore","slug":"NetCore","count":1,"path":"api/tags/NetCore.json"},{"name":"c#","slug":"c","count":2,"path":"api/tags/c.json"}],"author":{"name":"FaceMan","slug":"blog-author","avatar":"https://github.com/faceman0814/picx-images-hosting/raw/master/20241114/image.2vermeukr5.webp","link":"/","description":"从0开始，直到1。","socials":{"github":"https://github.com/faceman0814","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/manmanzainuli","juejin":"","customs":{"bokeyuan":{"icon":"/svg/bokeyuan.svg","link":"https://www.cnblogs.com/FaceMan"}}}}},"next_post":{"title":"NFS for CentOS","uid":"584404787b0b0e754117ced08ab7daf6","slug":"NFSforCentOS","date":"2024-11-19T00:00:00.000Z","updated":"2024-12-24T01:56:35.264Z","comments":true,"path":"api/articles/NFSforCentOS.json","keywords":null,"cover":"https://github.com/faceman0814/picx-images-hosting/raw/master/20241114/docker.4g4ilvor9o.webp","text":"NFS for CentOSNFS介绍NFS介绍NFS 即网络文件系统（Network File-System），可以通过网络让不同机器、不同系统之间可以实现文...","permalink":"/post/NFSforCentOS","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"DevOps","slug":"DevOps","count":11,"path":"api/categories/DevOps.json"}],"tags":[{"name":"CentOS","slug":"CentOS","count":1,"path":"api/tags/CentOS.json"},{"name":"Linux","slug":"Linux","count":3,"path":"api/tags/Linux.json"}],"author":{"name":"FaceMan","slug":"blog-author","avatar":"https://github.com/faceman0814/picx-images-hosting/raw/master/20241114/image.2vermeukr5.webp","link":"/","description":"从0开始，直到1。","socials":{"github":"https://github.com/faceman0814","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/manmanzainuli","juejin":"","customs":{"bokeyuan":{"icon":"/svg/bokeyuan.svg","link":"https://www.cnblogs.com/FaceMan"}}}}}}