[{"id":"2f6f4322594661f0414df8fc201523ed","title":"我在人间凑数的第8865天","content":"随便叭叭有时候想成为一个有思想深度的人，但奈何读书太少没啥文化，看书于我而言跟催眠无差别，于是我放弃🙄 。\n最近喜欢一个泰国女演员Orm，她身上蓬勃的生命力和明媚的笑容让我着迷，心理学上说，你喜欢某个事物是因为它具备你想拥有的特质，我觉得很对，但每个人的人生都是独有的且不具备复制性，如何挣扎向上，我还在摸索😵 。。。。\n很容易对一件事儿上头，过了几天又断崖下头，简称三分钟热度，或许这就是处女座不受待见的原因🙁 。\n分享欲旺盛是一把双刃剑，好的一面它可以使你主动去维系你想维系的关系，坏的一面就是万一分享错了人给别人带来困扰的同时，自己的热情也被打击，所以如何去控制分享欲是我需要学会的课题🐞 。\n","slug":"2024.12.24日常小记","date":"2024-12-24T01:56:11.053Z","categories_index":"日常","tags_index":"杂谈","author_index":"FaceMan"},{"id":"c63101490a44e6dea3cd9d49ca1e518b","title":"GitHubAction实现自动化部署","content":"由于我的服务器配置太低支持不了GitLab的CICD，所以我这里用GitHub Action来实现（感恩），上期我们说到docker官方镜像仓库即使你用代理也经常出现拉不下来的情况，所以我们可以换个思路，把镜像发布到阿里云的个人仓库，或者自己建一个docker私有镜像仓库，本着白嫖原则，本文使用阿里云私有镜像仓库服务。\n开通阿里云私有镜像仓库登录：阿里云镜像服务启用个人实例\n创建一个命名空间，并且设为公开（可以不用登陆直接拉镜像）\n创建好后去Github仓库设置环境变量\n这里云服务器要开放22端口，确保&#x2F;etc&#x2F;ssh&#x2F;sshd_config的配置如下\n123456# 如果是root登录，则配置PermitRootLogin yes# 允许密码登录PasswordAuthentication yes# 如果使用密钥登录，则配置PubkeyAuthentication yes\n\n配置后使用sudo systemctl restart sshd生效\n\n\n构建GitHubAction文件目录如下：\n12345678910Directory: D:\\Project\\DemosMode                 LastWriteTime         Length Name----                 -------------         ------ ----d----           2024/12/2    11:13                .githubd----           2024/12/2    11:13                .vscoded----           2024/12/2    11:13                src-a---           2024/12/2    15:45            549 .gitignore  -a---           2024/12/2    16:14            270 docker-compose.yml-a---           2024/11/1    13:45             27 README.md\n\n我的Dockerfile文件放在src下面，创建deploy.yml放在.github&#x2F;workflows，内容如下：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667name: Build and Deployon:  # 当代码被推送到仓库时触发  push:    branches:      - main  # 可以根据需要更改为你的目标分支jobs:  # 构建和推送 Docker 镜像  build:    # 在哪个环境下运行    runs-on: ubuntu-latest    steps:      # 检查代码    - name: Checkout code      uses: actions/checkout@v2      # 安装 Docker 构建工具    - name: Set up Docker Buildx      uses: docker/setup-buildx-action@v2      # 登录到阿里云 Docker 镜像仓库    - name: Log in to Alibaba Cloud Docker Registry      uses: docker/login-action@v2      with:        username: $&#123;&#123;secrets.ALIYUN_REGISTRY_USER&#125;&#125;        password: $&#123;&#123; secrets.ALIYUN_REGISTRY_PASSWORD &#125;&#125;        registry: $&#123;&#123; secrets.ALIYUN_REGISTRY &#125;&#125;      # 构建并推送 Docker 镜像    - name: Build and push Docker image      run: |        docker build -t $&#123;&#123; secrets.ALIYUN_REGISTRY &#125;&#125;/$&#123;&#123; secrets.ALIYUN_NAME_SPACE &#125;&#125;/$&#123;&#123; secrets.IMAGE_NAME &#125;&#125;:latest ./src        docker push $&#123;&#123; secrets.ALIYUN_REGISTRY &#125;&#125;/$&#123;&#123; secrets.ALIYUN_NAME_SPACE &#125;&#125;/$&#123;&#123; secrets.IMAGE_NAME &#125;&#125;:latest  deploy:    runs-on: ubuntu-latest    needs: build    environment:      name: production      url: https://xxxx      steps:      # 检查代码    - name: Checkout code      uses: actions/checkout@v2      # SSH 连接到服务器并部署应用    - name: SSH into server and deploy      uses: appleboy/ssh-action@v0.1.8      with:        host: $&#123;&#123; secrets.ALIYUN_SERVER_IP &#125;&#125;        username: $&#123;&#123; secrets.ALIYUN_SERVER_USER &#125;&#125;        password: $&#123;&#123; secrets.ALIYUN_SERVER_PASSWORD &#125;&#125;        port: 22        # 如果使用私钥登录则打开下列配置        # key: $&#123;&#123; secrets.SSH_PRIVATE_KEY &#125;&#125;        script: |          # 拉取镜像          docker pull $&#123;&#123; secrets.ALIYUN_REGISTRY &#125;&#125;/$&#123;&#123; secrets.ALIYUN_NAME_SPACE &#125;&#125;/$&#123;&#123; secrets.IMAGE_NAME &#125;&#125;:latest          # 停止之前的容器          docker stop $&#123;&#123; secrets.IMAGE_NAME &#125;&#125; || true          docker rm $&#123;&#123; secrets.IMAGE_NAME &#125;&#125; || true          # 启动容器          docker run -d --name $&#123;&#123; secrets.IMAGE_NAME &#125;&#125; -p 7121:80 $&#123;&#123; secrets.ALIYUN_REGISTRY &#125;&#125;/$&#123;&#123; secrets.ALIYUN_NAME_SPACE &#125;&#125;/$&#123;&#123; secrets.IMAGE_NAME &#125;&#125;:latest\n\n配置完推送分支就可以啦！\n\n","slug":"GitHubAction实现自动化部署","date":"2024-12-02T09:48:38.957Z","categories_index":"DevOps","tags_index":"CICD","author_index":"FaceMan"},{"id":"db862bea918e56d5ebf1541d0aa7193d","title":"Docker实现Linux科学上网","content":"没想到我还能在Clash这里吃亏，事情是这样的，以前只玩过gitlab的CICD，官方的要钱，自己部署的话服务器配置有要求，而且我的项目基本都开源，所以今天准备研究下GitHub的CICD——Github Actions。经过上一篇文章，我准备了一个叫webtest的镜像，然后在我99一年的阿里云服务器上准备拉下来做实验，发现，拉不下来！报错如下：\n1Error response from daemon: Get “https://registry-1.docker.io/v2/”: context deadline exceeded\n\n网上找了很多方法无非几种：\n\n改DNS\n配置其他镜像源\n上代理\n\n我这里因为是上传到docker的官方镜像仓库，所以改DNS和镜像源没有用，所以就剩一招了，上代理。\n于是，我就开始往Ubuntu上折腾Clash，因为我之前弄过Clash，但我不记得我为啥关了，用的是Ubuntu系统下systemctl start clash的启动方式，具体的可以参考我的文章：Clash for Ubuntu，问题又来了，我发现官方提供的链接面板Clash (razord.top)死活连不上，要么报跨域，要么就是Net Error啥的，我查了下相关issue，clash的设计问题，最好是设置密码，于是我又去config.yml设置密码，但发现偶尔能连上，大部分时间连不上，不稳定。于是我又慢慢搜索解决方案，发现可以用yacd来解决，这个也有提供官方的链接yacd (haishan.me)供你使用，但我试了下偶尔也不稳定，于是我自己部署，一下就搞定了！但这里有个要注意的地方就是如果你加了证书，那么两个都要加不然也识别不到。\nDocker教程这里我提供一个DockerCompose来部署，用systemctl部署麻烦得很，还要想办法找源文件,而且有更改的话很麻烦，docker方便。\n首先，去代理软件复制节点订阅地址,准备一个config.yml配置文件，放到&#x2F;root&#x2F;.config&#x2F;clash路径下，参考Clash for Ubuntu (notion.so)获取这里我不重复说明。\n然后设置密码\n再然后创建clash&#x2F;docker-compose.yml文件\n1234567891011121314151617181920212223242526version: &#x27;3.9&#x27;services:  yacd:    image: ghcr.io/haishanh/yacd:master    container_name: yacd    ports:      - &quot;1234:80&quot;    restart: unless-stopped  clash:    image: dreamacro/clash    container_name: clash    volumes:      - ./.config/clash:/root/.config/clash      # - ./ui:/ui # dashboard volume (uncomment if needed)    ports:      - &quot;7890:7890&quot;      - &quot;7891:7891&quot;      # - &quot;8080:8080&quot; # external controller (Restful API, uncomment if needed)    # TUN capabilities (uncomment if needed)    # cap_add:    #   - NET_ADMIN    # devices:    #   - /dev/net/tun    restart: unless-stopped    network_mode: &quot;host&quot;  # use &quot;bridge&quot; mode in non-Linux environments if required\n\n再再然后执行docker compose up -d\n如果是云服务器记得开放1234和9090端口\n\nPS：有时候有代理也拉不到docker官方的镜像，网络问题，垃圾的很，所以建议大家自己的镜像可以放到自己的私有仓库里。\n","slug":"Linux科学上网","date":"2024-11-30T16:33:41.616Z","categories_index":"DevOps","tags_index":"Docker,Clash","author_index":"FaceMan"},{"id":"32b006c2c9398b6cfeebb21599635996","title":"Docker构建、打包、部署一条龙的过程","content":"Web项目写好后，我习惯用Docker打包成镜像然后部署到服务器上使用，理由是方便，后面迭代的时候只需要更换镜像就能完成部署，甚至更方便点使用cicd完成自动化部署，那么学会写DockerFile文件就是必不可少的了，那废话少说，实践开始！\n1、构建DockerFile我的文件目录为：\n123456789101112PS D:\\Study\\Demos\\src&gt; ls    Directory: D:\\Study\\Demos\\srcMode                 LastWriteTime         Length Name----                 -------------         ------ ----d----          2024/11/29    14:40                FaceMan.EFTestd----          2024/11/29    16:31                FaceMan.WebTest-a---          2024/11/29    13:55         309048 config.json-a---          2024/11/29    14:51           2642 Demo.sln-a---          2024/11/29    16:31           1170 Dockerfile-a---          2024/11/29    15:09            640 version.props\n\n所以我的DockerFile是这样写的：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344# 使用官方的 ASP.NET Core Runtime 镜像FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS base# 设置工作目录WORKDIR /app# 开放应用所需的端口EXPOSE 80# 使用官方的.NET SDK镜像作为构建环境FROM mcr.microsoft.com/dotnet/sdk:9.0 AS buildWORKDIR /src# 复制项目文件到容器中COPY [&quot;FaceMan.EFTest/FaceMan.EFTest.csproj&quot;, &quot;FaceMan.EFTest/&quot;]COPY [&quot;FaceMan.WebTest/FaceMan.WebTest.csproj&quot;, &quot;FaceMan.WebTest/&quot;]# 还原和编译项目RUN dotnet restore &quot;FaceMan.WebTest/FaceMan.WebTest.csproj&quot;# 复制整个项目到容器中COPY . .WORKDIR &quot;/src/FaceMan.WebTest&quot;RUN dotnet build &quot;FaceMan.WebTest.csproj&quot; -c Release -o /app/buildFROM build AS publishRUN dotnet publish &quot;FaceMan.WebTest.csproj&quot; -c Release -o /app/publish /p:UseAppHost=false# 从构建环境中复制编译好的文件FROM base AS finalWORKDIR /appCOPY --from=publish /app/publish .#定义时区参数ENV TZ=Asia/Shanghai#设置时区RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo &#x27;$TZ&#x27; &gt; /etc/timezone# 设置容器启动时执行的命令ENTRYPOINT [&quot;dotnet&quot;, &quot;FaceMan.WebTest.dll&quot;]\n\n2、打包成镜像导航到Dockerfile所在路径执行命令：docker build -t 镜像名称 .例如：docker build -t webtest .\nps：一定要有这个‘.’\n3、启动容器镜像打完之后就可以根据镜像启动容器了：docker run 镜像\n.net不知道几代升级之后就必须要指定端口了，我的默认生成的是8080，所以我需要用-p来映射我实际的端口：docker run -d -p 7121:8080 --name my-running-app webtest 其中my-running-app是容器名字，webtest是镜像名字\n4、使用DockerCompose启动创建文件docker-compose.yml的内容为：\n12345678910version: &#x27;3.8&#x27;services:  demo-app:    image: webtest    ports:      - &quot;7121:8080&quot;    environment:      #设置环境变量，设置为开发环境      ASPNETCORE_ENVIRONMENT: Development\n\n然后执行部署命令：docker compose up -d\n撤销部署命令为：docker compose down\n5、推送镜像到镜像仓库刚刚我们制作的镜像为：webtest，如果我们需要推送到镜像仓库的话就需要改下名字，要在前面加上你docker仓库的用户名，比如我的叫：faceman0814&#x2F;webtest。这里我们用tag命令来重新创建一个faceman0814&#x2F;webtest镜像：docker tag webtest faceman0814/demo\n然后推送：docker push faceman0814/webtest\n拉取命令：docker pull faceman0814/webtest\n指定版本的话在拉取命令加上:版本，默认是最后一个版本\n完结自此简单基础的镜像构建，容器部署的过程就结束了，完结撒花！\n","slug":"构建DockerFile","date":"2024-11-29T10:07:43.764Z","categories_index":"DevOps","tags_index":"Docker","author_index":"FaceMan"},{"id":"effef2644cf5d4dbdf4ef3a751e9c7bc","title":" Docker拉取netsdk镜像","content":"在写DockerFile文件时，发现直接拉取mcr.microsoft.com/dotnet/sdk:9.0报错：\n123PS D:\\Study\\Demos\\Demo&gt; docker pull mcr.microsoft.com/dotnet/sdk:9.0Error response from daemon: Get &quot;https://mcr.microsoft.com/v2/&quot;: EOF\n\n解决方案：\n\n安装newbe.mcrmirror：dotnet tool install newbe.mcrmirror -g\n安装 .NET Core 3.1 框架：访问 Microsoft .NET Core 下载页面。\n执行命令：docker-mcr -i mcr.microsoft.com/dotnet/sdk:9.0\n查看是否安装成功：dotnet --list-runtimes\n拉取.net 9.0 SDK：docker pull mcr.microsoft.com/dotnet/sdk:9.0\n\n","slug":"docker拉取netsdk镜像","date":"2024-11-29T00:00:00.000Z","categories_index":"DevOps","tags_index":"Docker,.Net SDK","author_index":"FaceMan"},{"id":"2fa7613b39e74fc504fcd245fd9c9634","title":"acme证书指南","content":"通常我们自己的网站比如博客、个人网站、小程序等都需要使用SSL证书来确保安全。但是申请证书并不是一件简单的事情，需要有一定的经验和知识。本文将介绍如何使用acme.sh来自动申请和续期SSL证书。\n什么是acme？acme（Automatic Certificate Management Environment，自动证书管理环境）是一个开源的证书颁发机构（CA）软件，它可以自动为网站、服务提供证书。\nacme的工作原理acme的工作原理是，当用户访问网站或服务时，如果网站或服务的证书已经过期，则acme会向证书颁发机构（CA）请求证书。CA会对用户的身份信息进行验证，并签发证书。acme会自动安装并更新证书。\n证书的类型acme支持多种证书类型，包括：\n\nRSA证书：最常用的证书类型，由RSA算法生成的证书，安全性较高。\nECC证书：由椭圆曲线算法生成的证书，安全性较高。\n多域名证书：可以为多个域名生成证书，可以有效防止域名劫持。\n通配符证书：可以为多个子域名生成证书，可以有效防止泛域名证书被攻击。\n自签名证书：可以为网站或服务提供自签名证书，可以有效防止证书被篡改。\n\nacme的常用命令acme的常用命令有：\n\nacme.sh --issue -d example.com -w /path/to/webroot：签发example.com的证书，并将证书安装到&#x2F;path&#x2F;to&#x2F;webroot目录。\nacme.sh --renew -d example.com -w /path/to/webroot：续期example.com的证书，并将证书安装到&#x2F;path&#x2F;to&#x2F;webroot目录。\nacme.sh --revoke -d example.com：吊销example.com的证书。\nacme.sh --install-cert -d example.com -w /path/to/webroot：安装example.com的证书到&#x2F;path&#x2F;to&#x2F;webroot目录。\nacme.sh --update-account-key：更新acme账户的私钥。\nacme.sh --upgrade：升级acme到最新版本。\n\n参考：acme.sh 官方文档\n颁发证书准备工作\n\n\n\n\n\n\n购买域名和服务器\n\n准备服务器（云服务器或自建服务器）\n服务器需要安装docker和docker-compose，这里我用的是v2版本的docker-compose语法。\n服务器需要开放80和443端口\n\n\n准备域名\n购买域名，并将域名解析到服务器的IP地址。\n\n\n\n\n\n如果不会请百度或者看我的其他文章，这里不再赘述。\n安装acme.sh和nginx\nacme用来自动签发证书，nginx用来配置证书的安装。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950version: &#x27;3.8&#x27;services:  nginx:    container_name: nginx    image: nginx    restart: always    network_mode: host    logging:      options:        max-size: &#x27;2048m&#x27;        max-file: &#x27;10&#x27;    labels:      - nginx    volumes:      - /docker/nginx/acme/d1:/domains      - /docker/nginx/conf.d:/etc/nginx/conf.d      - /docker/nginx/nginx.conf:/etc/nginx/nginx.conf      - /docker/nginx/www:/var/www      - /root/static_website:/static_website  acme.sh:    container_name: acme.sh    image: neilpang/acme.sh:3.0.5    restart: always    command: daemon    logging:      options:        max-size: &#x27;2048m&#x27;        max-file: &#x27;10&#x27;    volumes:      # 挂载主机路径到容器路径，用于保存acme.sh脚本      - /docker/nginx/acme:/acme.sh      # 挂载主机路径到容器路径，允许容器通过docker.sock与本地docker服务通信      - /var/run/docker.sock:/var/run/docker.sock    environment:      # 设置容器的部署标签，用于自动加载与nginx相关的配置      - DEPLOY_DOCKER_CONTAINER_LABEL=nginx      # 设置容器的自动重载命令，在容器发生变化时执行该命令重新加载nginx配置      - DEPLOY_DOCKER_CONTAINER_RELOAD_CMD=&quot;service nginx force-reload&quot;      # 设置阿里云的Access Key      - Ali_Key=********      # 设置阿里云的Secret Key      - Ali_Secret=************      # 设置华为云的用户名      - HUAWEICLOUD_Username=********      # 设置华为云的密钥      - HUAWEICLOUD_Password=*********      # 设置华为云的域名      - HUAWEICLOUD_DomainName=********\n\n\n\n签发证书123456789101112//阿里云解析：dns_ali  //华为云解析：dns_huaweicloudsudo docker exec \\ acme --issue --dns dns_ali \\ -d example.com \\ --cert-file\t    /acme.sh/domains/example.com/cert.cert \\ --key-file         /acme.sh/domains/example.com/key.key \\ --ca-file          /acme.sh/domains/example.com/ca.cer \\ --fullchain-file   /acme.sh/domains/example.com/fullchain.pem \\ --force//example.com为域名\n\n自动化续签1docker exec acme.sh  --upgrade  --auto-upgrade\n\n重载配置1docker exec -it nginx  service nginx force-reload\n\nnignx配置1234567891011121314151617181920212223error_log /var/log/nginx/error.log;server &#123;    listen 80;    listen 443 ssl;    server_name example.com;    ssl_protocols TLSv1.2 TLSv1.1 TLSv1;       ssl_certificate      /domains/fullchain.pem; //证书路径    ssl_certificate_key  /domains/key.key; //密钥路径    ssl_prefer_server_ciphers on;     ssl_session_timeout  5m;    if ($server_port = 80) &#123;    rewrite ^(.*)$ https://$host$1 permanent;    &#125;    location / &#123;        proxy_pass ip地址加端口号;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        root /home/web/;        index index.php;    &#125;&#125;\n\n重启nginx1docker restart nginx\n\n完结至此，acme证书申请和续期的流程已经介绍完毕，访问自己的网站或服务时你会看到https的锁，如果证书已经过期，则会自动申请和安装证书。\n","slug":"acme证书指南","date":"2024-11-28T00:00:00.000Z","categories_index":"DevOps","tags_index":"SSL,Liunx","author_index":"FaceMan"},{"id":"6077b98b9ff0688a2006567048ac9630","title":"Qexo：博客的管理和自动化发布","content":"Hexo是一个模板很多的静态博客生成工具，但是每次都需要打开编译器进行博客撰写和使用命令行生成发布未免有点太繁琐，本篇文章就来总结大佬的可视化博客撰写内容和自动化部署博客方法。\nQexo在逛Github时看到这个项目我的眼睛一亮，可以管理hexo的博客内容，亲测好用，这里不展开讲，因为官方文档足够详细，如果过程中遇到问题先查看issue，一般都能解决：Qexo | 一个美观、强大的在线 静态博客 管理器\n自动化部署博客为了简化Hexo部署过程，你可以使用持续集成工具（如 GitHub Actions）来实现自动化部署。\n1、创建博客源代码仓库因为我们需要 Hexo 源代码才能生成静态文件，所以我们需要建立一个私有仓库来保存我们的源代码，当然如果你觉得麻烦也可以建立一个分支保存，不过通常我们会将纯静态文件和源码文件分别存放到两个仓库里，一个可以作为公开仓库对外展示，源码目录需要设为私有，有利于更好地保护你的文章版权。\n2、生成 Github Token点击头像 &#x3D;&gt; Settings &#x3D;&gt; Developer settings &#x3D;&gt;Personal access tokens &#x3D;&gt; Tokens(classic) &#x3D;&gt; Generate new token &#x3D;&gt; Generate new token(classic)\n\n设置根据需要设置过期时间，我这里设置永不过期，权限勾选repo以及 workflow，生成后记得保存起来，只显示一次。\n3、修改 config.yml把 config.yml 文件中的 deploy &#x3D;&gt; repository &#x3D;&gt; github 值改成 token url 的形式。\n12345678910deploy:  - type: git    repo: https://&#123;$GH_TOKEN&#125;@github.com/shiguang-coding/shiguang-coding.github.io.git,maindeploy:- type: git  repo: https://&#123;$GH_TOKEN&#125;@github.com/shiguang-coding/shiguang-coding.github.io.git,main\n\n将 {$GH_TOKEN} 替换成刚才生成的 token ，仓库地址是博客静态文件最终存放的仓库地址，即开通 Github Pages 服务的那个仓库地址。\n这里可以同时部署到多个仓库，只需复制一份配置信息即可\n12345678910111213deploy:  - type: git    repo: https://&#123;$GH_TOKEN&#125;@github.com/your-name/your-name.github.io.git,main  - type: git    repo: https://&#123;$GH_TOKEN&#125;@github.com/your-name/your-repo.git,maindeploy:- type: git  repo: https://&#123;$GH_TOKEN&#125;@github.com/your-name/your-name.github.io.git,main- type: git  repo: https://&#123;$GH_TOKEN&#125;@github.com/your-name/your-repo.git,main\n\n4、创建 GitHub Actions 脚本GitHub Actions 的工作流文件存放在源代码仓库的 .github&#x2F;workflows 目录。workflow 文件采用 YAML 格式，文件名可以任意取，但是后缀名统一为 .yml，比如 deploy.yml。一个库可以有多个 workflow 文件。GitHub 在我们完成预设触发条件时，只要发现 .github&#x2F;workflows 目录里面有 .yml 文件，就会自动读取运行该文件。\n可以手动建立此文件，或者通过源代码仓库 &#x3D;&gt; Actions &#x3D;&gt; 选择 Setup Node创建，但最终同样都需 push 到远端源代码仓库中。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152name: FaceMan&#x27;s Blog CI/CD # 脚本 workflow 名称on:  push:    branches: [main, master] # 当监测 main,master 的 push    paths: # 监测所有 source 目录下的文件变动，所有 yml,json 后缀文件的变动。      - &#x27;*.json&#x27;      - &#x27;**.yml&#x27;      - &#x27;**/source/**&#x27;jobs:  blog: # 任务名称    timeout-minutes: 30 # 设置 30 分钟超时    runs-on: ubuntu-latest # 指定最新 ubuntu 系统    steps:      - uses: actions/checkout@v2 # 拉取仓库代码      - uses: actions/setup-node@v2 # 设置 node.js 环境        with:          node-version: &#x27;18&#x27;  # 根据你的 Node.js 版本进行调整      - name: Cache node_modules # 缓存 node_modules，提高编译速度，毕竟每月只有 2000 分钟。        uses: actions/cache@v2        env:          cache-name: cache-node-modules        with:          path: ~/.npm          key: $&#123;&#123; runner.os &#125;&#125;-build-$&#123;&#123; env.cache-name &#125;&#125;-$&#123;&#123; hashFiles(&#x27;**/package-lock.json&#x27;) &#125;&#125;          restore-keys: |            $&#123;&#123; runner.os &#125;&#125;-build-$&#123;&#123; env.cache-name &#125;&#125;-            $&#123;&#123; runner.os &#125;&#125;-build-            $&#123;&#123; runner.os &#125;&#125;-      - name: Init Node.js # 安装源代码所需插件        run: |          npm install          echo &quot;init node successful&quot;      - name: Install Hexo-cli # 安装 Hexo        run: |          npm install -g hexo-cli --save          echo &quot;install hexo successful&quot;      - name: Build Blog # 编译创建静态博客文件        run: |          hexo clean          hexo g          # echo &quot;自定义域名&quot; &gt; public/CNAME          echo &quot;build blog successful&quot;      - name: FaceMan&#x27;s Blog # 设置 git 信息并推送静态博客文件        run: |          git config --global user.name &quot;your name&quot;          git config --global user.email &quot;your email&quot;          hexo deploy      - run: echo &quot;Deploy Successful!&quot;\n\n如果需要加自定义域名，就把脚本中自定义域名替换为你的域名，并且删除#。\n代码提交前需要检查下是否已安装一键部署插件 hexo-deployer-git。\n12npm install hexo-deployer-git --save\n\n若提示 Deployer not found: git 则说明尚未引入该插件依赖。\n代码提交后会自动执行 Actions，可查看部署记录及日志，部署失败也会有邮件提醒。\n\n","slug":"使用Qexo完成对Hexo博客的管理和自动化发布","date":"2024-11-28T00:00:00.000Z","categories_index":"","tags_index":"Hexo","author_index":"FaceMan"},{"id":"2fad6525e464e362f1913614556fcda3","title":"运维常用命令","content":"在操作项目部署的时候，经常会忘记一些命令，从而百度或者gpt，这里记录一些常用的命令操作。\nDocker配置docker镜像加速器12345678910111213141516171819202122vi /etc/docker/daemon.json&#123;    &quot;registry-mirrors&quot;: [&quot;https://docker.registry.cyou&quot;,  &quot;https://docker-cf.registry.cyou&quot;,  &quot;https://dockercf.jsdelivr.fyi&quot;,  &quot;https://docker.jsdelivr.fyi&quot;,  &quot;https://dockertest.jsdelivr.fyi&quot;,  &quot;https://mirror.aliyuncs.com&quot;,  &quot;https://dockerproxy.com&quot;,  &quot;https://mirror.baidubce.com&quot;,  &quot;https://docker.m.daocloud.io&quot;,  &quot;https://docker.nju.edu.cn&quot;,  &quot;https://docker.mirrors.sjtug.sjtu.edu.cn&quot;,  &quot;https://docker.mirrors.ustc.edu.cn&quot;,  &quot;https://mirror.iscas.ac.cn&quot;,  &quot;https://docker.rainbond.cc&quot;]  &#125;//重新加载配置systemctl daemon-reload//重启docker服务systemctl restart docker\n\n配置DNS服务器1234567sudo nano /etc/systemd/resolved.conf//输入[Resolve]DNS=8.8.8.8 8.8.4.4//重启生效sudo systemctl restart systemd-resolved.service\n\n容器相关命令12345678910111213141516171819202122//启动容器docker run -d --name nginx -p 80:80 nginx//进入容器docker exec -it nginx /bin/bash//查看日志docker logs nginx//查看容器IP地址docker inspect nginx | grep IPAddress//查看当前运行的容器docker ps//查看所有容器docker ps -a//启动容器docker start nginx//停止容器docker stop nginx//重启容器docker restart nginx//删除容器docker rm nginx//删除所有停止的容器docker container prune\n\n镜像相关命令123456789//拉取镜像docker pull nginx//查看本地镜像docker images//删除镜像docker rmi nginx//删除所有镜像docker rmi $(docker images -q)\n\n网络相关命令123456789//查看所有网络docker network ls//创建网络docker network create my-net//删除网络docker network rm my-net//连接到网络docker run -d --name nginx --net my-net -p 80:80 nginx\n\n数据卷相关命令123456789//创建数据卷docker volume create my-vol//查看数据卷docker volume ls//挂载数据卷docker run -d --name nginx -v my-vol:/usr/share/nginx/html nginx//删除数据卷docker volume rm my-vol\n\n其他命令123456789101112131415161718//查看所有命令docker//查看版本docker version//查看系统信息docker info//登录镜像仓库docker login//退出镜像仓库docker logout//导出镜像docker save -o my-image.tar my-image//导入镜像docker load -i my-image.tar//导入/导出容器docker export my-container &gt; my-container.tardocker import my-container.tar\n\nDocker Compose命令 V2的写法1234567//启动容器docker compose up -d//停止容器docker compose stop//删除容器docker compose down\n\nDocker Stack123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//创建stackdocker stack deploy -c docker-compose.yml my-stack//更新stackdocker stack deploy -c docker-compose.yml my-stack//删除stackdocker stack rm my-stack//查看stackdocker stack ls//查看stack的服务docker stack services my-stack//查看stack的容器docker stack ps my-stack//查看stack的日志docker stack logs my-stack//查看stack的配置docker stack config my-stack//查看stack的节点docker node ls//查看节点的服务docker node ps node-name//查看节点的容器docker node ps node-name//查看节点的日志docker node logs node-name//查看节点的配置docker node inspect node-name//添加节点docker swarm join-token manager//删除节点docker swarm leave --force//更新节点docker node update node-name --availability drain//更新服务docker service update --image nginx my-stack_nginx//更新stackdocker stack deploy -c docker-compose.yml my-stack//查看服务的健康状态docker service ps my-stack_nginx//重新部署服务docker service update --force my-stack_nginx//删除服务docker service rm my-stack_nginx//查看服务的日志docker service logs my-stack_nginx//查看服务的配置docker service inspect my-stack_nginx//查看服务的节点docker service ps my-stack_nginx --no-trunc\n\nLinux文件相关命令123456789101112131415161718192021222324// 创建文件夹mkdir myfolder// 切换目录cd myfolder// 查看当前目录pwd// 查看当前目录下的文件ls// 查看文件内容cat file.txt // 复制文件cp file1.txt file2.txt // 移动文件mv file1.txt file2.txt // 删除文件rm file.txt // 删除文件夹rm -r myfolder // 创建文件touch file.txt // 编辑文件vi file.txt // 编辑文件，并保存退出:wq \n\n压缩解压相关命令123456789101112// 压缩文件tar -cvf file.tar file1.txt file2.txt // 解压文件tar -xvf file.tar // 压缩文件夹tar -zcvf file.tar.gz folder // 解压文件夹tar -zxvf file.tar.gz // 压缩文件，并指定压缩级别tar -zcvf - file1.txt file2.txt | pv -l &gt;/dev/null // 解压文件，并显示进度条tar -zxvf file.tar.gz | pv -l &gt;/dev/null \n\n网络相关命令12345678910111213141516// 查看网络信息ifconfig // 查看路由信息route // 查看端口信息netstat -anp // 查看端口是否被占用lsof -i:8080 // 查看网络连接信息ss -tuln // 查看网络连接信息，并显示进度条ss -tuln | pv -l &gt;/dev/null // 查看网络连接信息，并显示详细信息ss -tuln -o state established &#x27;( dport = :ssh or sport = :ssh )&#x27; // 查看网络连接信息，并显示详细信息，并显示进度条ss -tuln -o state established &#x27;( dport = :ssh or sport = :ssh )&#x27; | pv -l &gt;/dev/null \n\n防火墙相关命令12345678910// 开启防火墙systemctl start firewalld // 关闭防火墙systemctl stop firewalld // 查看防火墙状态systemctl status firewalld // 允许端口firewall-cmd --zone=public --add-port=8080/tcp --permanent // 重启防火墙firewall-cmd --reload \n\nNuget命令1234567891011121314151617// 安装包nuget install PackageName// 卸载包nuget uninstall PackageName// 更新包nuget update PackageName// 发布包nuget push PackageName.nupkg -Source https://api.nuget.org/v3/index.json发布您的第一个包：dotnet nuget push -s http://localhost:5555/v3/index.json -k NUGET-SERVER-API-KEY package.1.0.0.nupkg发布您的第一个元件包：dotnet nuget push -s http://localhost:5555/v3/index.json -k NUGET-SERVER-API-KEY symbol.package.1.0.0.snupkg// 列出包nuget list// 列出包，并显示版本号nuget list -AllVersions\n\nGit命令123456789101112131415161718192021222324252627282930// 克隆仓库git clone https://github.com/username/repository.git// 切换分支git checkout branch-name// 创建分支git branch branch-name// 合并分支git merge branch-name// 查看状态git status// 添加文件git add file-name// 提交文件git commit -m &quot;commit message&quot;// 推送到远程仓库git push origin branch-name// 拉取远程仓库git pull origin branch-name// 查看日志git log// 撤销上一次提交git reset --hard HEAD^// 撤销所有提交git reset --hard origin/master// 回滚到指定版本git reset --hard commit-id// 删除远程分支git push origin --delete branch-name// 删除本地分支git branch -d branch-name\n\nDotNet命令1234567891011121314// 编译项目dotnet build// 运行项目dotnet run// 发布项目dotnet publish -c Release -o ./bin/bash// 添加包dotnet add package PackageName// 还原包dotnet restore// 运行单元测试dotnet test// 运行dotnet命令dotnet --info\n","slug":"运维常用命令","date":"2024-11-28T00:00:00.000Z","categories_index":"DevOps","tags_index":"Docker,Linux","author_index":"FaceMan"},{"id":"15cdd7edd7d25fc2ae3b2ddd5c892e87","title":"动态API集成","content":"在日常开发时，想要用到Swagger就必须得创建控制器创建接口文档，一般业务处理都不会在控制器中处理，我们一般会再创建另一个类来处理业务逻辑，每次创建都两个类就很繁琐，这篇文章就是为了解决这个繁琐，关心源码的朋友可以直接参考我的文章：!动态API集成源码解析版，或者去github上下载源码：!动态API仓库。\n功能动态扫描生成Swagger API接口。支持三种方式：\n\n继承IApplicationService接口\n标记DynamicWebApi特性\n原生ApiController\n\n教程必要配置：在appsettings.json配置请求类型规则,例如以Get或者Query开头的方法，就会被识别为Get类型。\n123456789101112131415161718&quot;HttpMethodInfo&quot;: [  &#123;    &quot;MethodKey&quot;: &quot;Get&quot;,    &quot;MethodVal&quot;: [ &quot;GET&quot;, &quot;QUERY&quot; ]  &#125;,  &#123;    &quot;MethodKey&quot;: &quot;Post&quot;,    &quot;MethodVal&quot;: [ &quot;CREATE&quot;, &quot;SAVE&quot;, &quot;INSERT&quot;, &quot;ADD&quot; ]  &#125;,  &#123;    &quot;MethodKey&quot;: &quot;Put&quot;,    &quot;MethodVal&quot;: [ &quot;UPDATE&quot;, &quot;EDIT&quot; ]  &#125;,  &#123;    &quot;MethodKey&quot;: &quot;Delete&quot;,    &quot;MethodVal&quot;: [ &quot;Delete&quot;, &quot;REMOVE&quot;, &quot;Del&quot; ]  &#125;]\n\n也自定义http特性，跟Controller一样加[HttpPost]就可以了\n在Program设置Swagger配置项\n123456789101112var conifg = new SwaggerConfigParam()&#123;    Title = &quot;FaceMan API&quot;,    Version = &quot;v1&quot;,    HttpMethods = builder.Configuration.GetSection(&quot;HttpMethodInfo&quot;).Get&lt;List&lt;HttpMethodConfigure&gt;&gt;()&#125;;builder.Services.AddDynamicApi(builder.Environment.WebRootPath, conifg);//其他配置app.UseSwagger(conifg);\n\n用法参考Example\n其他配置项文档注释1、要开启文档注释，首先需要在类库属性中设置XML文件路径2、启用SwaggerConfigParam的文档注释配置\n123456var conifg = new SwaggerConfigParam()&#123;    //其他配置    EnableXmlComments=ture,    ApiDocsPath = &quot;ApiDocs&quot;&#125;;\n\n3、在启动项目属性页配置如下代码这里类库命名最好有个通用前缀，不然只能一条条写了，比如FaceMan.Web、FaceMan.Domain\n12345678910111213141516171819   &lt;PropertyGroup&gt;    &lt;!--其他配置--&gt;\t&lt;ApiDocDir&gt;wwwroot\\ApiDocs&lt;/ApiDocDir&gt;&lt;/PropertyGroup&gt;&lt;!--在构建项目后，复制所有以FaceMan开头的XML文档文件到指定的API文档目录。这通常用于将生成的XML文档文件（例如API注释）整理到一个目录中，便于进一步的处理或发布。这种做法可以适合于生成API文档如Swagger时的使用场景。--&gt;&lt;Target Name=&quot;CopyXmlDocFileForBuild&quot; AfterTargets=&quot;Build&quot;&gt;\t&lt;ItemGroup&gt;\t\t&lt;XmlDocFiles Include=&quot;$(OutDir)$(AssemblyName).xml&quot; /&gt;\t\t&lt;!--Include=&quot;@(ReferencePath-&gt;&#x27;%(RootDir)%(Directory)%(Filename).xml&#x27;)&quot;：这行表示从所有项目引用（ReferencePath）的路径中收集以.xml为扩展名的文件。这些文件通常是生成的XML文档文件。--&gt;\t\t&lt;!--Condition=&quot;$([System.String]::new(&#x27;%(FileName)&#x27;).StartsWith(&#x27;FaceMan&#x27;))&quot;：此条件用于过滤文件，仅包括文件名以FaceMan开头的XML文档文件。这保证只有相关的文档文件被选择。--&gt;\t\t&lt;XmlDocFiles Include=&quot; @(ReferencePath-&gt;&#x27;%(RootDir)%(Directory)%(Filename).xml&#x27;)&quot; Condition=&quot;$([System.String]::new(&#x27;%(FileName)&#x27;).StartsWith(&#x27;FaceMan&#x27;))&quot; /&gt;\t&lt;/ItemGroup&gt;\t&lt;!--SourceFiles=&quot;@(XmlDocFiles)&quot;：指定要复制的源文件为上一步中定义的XmlDocFiles集合。--&gt;\t&lt;!--`Condition=&quot;Exists(&#x27;%(FullPath)&#x27;)&quot;：确保复制前源文件存在，这是一种安全检查。--&gt;\t&lt;!--DestinationFolder=&quot;$(ApiDocDir)&quot;：目的地文件夹为$(ApiDocDir)，这个属性之前已经在项目文件中定义，指向存放API文档的目录。--&gt;\t&lt;!--SkipUnchangedFiles=&quot;true&quot;：此选项表示只有发生变化的文件会被复制，这可以提高效率，避免不必要的复制操作。--&gt;\t&lt;Copy SourceFiles=&quot;@(XmlDocFiles)&quot; Condition=&quot;Exists(&#x27;%(FullPath)&#x27;)&quot; DestinationFolder=&quot;$(ApiDocDir)&quot; SkipUnchangedFiles=&quot;true&quot; /&gt;&lt;/Target&gt;\n\n配置完启动就可以看见啦\nSwagger登录页一般来说Swagger都会需要登录才能进行接口调用，所以需要一个登录页，如果需要鉴权请自己实现。\n1234567var conifg = new SwaggerConfigParam()&#123;    //其他配置    EnableLoginPage=true,    WebRootPath=builder.Environment.WebRootPath,    LoginPagePath = &quot;pages/swagger.html&quot;&#125;;\n\n在wwwroot下pages目录下创建swagger.html文件\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;title&gt;Swagger UI&lt;/title&gt;    &lt;!-- 使用 Swagger UI 默认的 CSS 样式 --&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/4.1.0/swagger-ui.min.css&quot;&gt;    &lt;style&gt;        body &#123;            margin: 0;            padding: 0;            font-family: Arial, sans-serif;        &#125;        .swagger-ui .scheme-container &#123;            margin: 0px;            padding: 0px;        &#125;        .button-container &#123;            justify-content: center;            right: 5%;            top: 10%;            position: absolute        &#125;            .button-container button &#123;                margin: 0 10px;                padding: 10px 20px;                font-size: 14px;                border: none;                background-color: #1b1b1b;                color: #fff;                cursor: pointer;                border-radius: 4px;            &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;button-container&quot;&gt;        &lt;!--&lt;button id=&quot;hangfireButton&quot;&gt;跳转到 Hangfire&lt;/button&gt;--&gt;        &lt;button id=&quot;logoutButton&quot;&gt;退出登录&lt;/button&gt;    &lt;/div&gt;    &lt;div id=&quot;swagger-ui&quot;&gt;&lt;/div&gt;    &lt;!-- 加载 Swagger UI 的 JavaScript --&gt;    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/4.1.0/swagger-ui-bundle.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/4.1.0/swagger-ui-standalone-preset.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/js-cookie/3.0.1/js.cookie.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        window.onload = function () &#123;            var configObject = JSON.parse(&#x27;%(ConfigObject)&#x27;);            const cookie = Cookies.get(&#x27;access-token&#x27;);            if (!cookie) &#123;                window.location.href = &#x27;/home/index&#x27;;            &#125;            // 配置 SwaggerUI            configObject.dom_id = &quot;#swagger-ui&quot;;            configObject.presets = [SwaggerUIBundle.presets.apis, SwaggerUIStandalonePreset];            configObject.layout = &quot;StandaloneLayout&quot;;            configObject.requestInterceptor = function (request) &#123;                // 添加 Authorization 头                request.headers[&#x27;Authorization&#x27;] = &#x27;Bearer &#x27; + cookie;                return request;            &#125;;            // 设置 OAuth2 重定向 URL            if (!configObject.hasOwnProperty(&quot;oauth2RedirectUrl&quot;)) &#123;                configObject.oauth2RedirectUrl = window.location + &quot;oauth2-redirect.html&quot;;            &#125;            configObject.plugins = [                function (system) &#123;                    return &#123;                        components: &#123;                            authorizeBtn: function () &#123;                                return null;                            &#125;                        &#125;                    &#125;;                &#125;            ];            // 初始化 Swagger UI            SwaggerUIBundle(configObject);            // 跳转到 Hangfire 并打开新页面            document.getElementById(&quot;hangfireButton&quot;).addEventListener(&quot;click&quot;, function () &#123;                window.open(&quot;/hangfire&quot;, &quot;_blank&quot;); // 替换 &quot;/hangfire&quot; 为正确的 Hangfire 页面 URL            &#125;);            // 退出登录并清除 cookie            document.getElementById(&quot;logoutButton&quot;).addEventListener(&quot;click&quot;, function () &#123;                Cookies.remove(&quot;access-token&quot;); // 清除名为 &quot;access-token&quot; 的 cookie                window.location.href = &quot;/Home/Index&quot;; // 替换 &quot;/home/logout&quot; 为正确的退出登录 URL            &#125;);        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n新建一个LoginController\n123456789    public class LoginController : Controller    &#123;        // GET: LoginController        public ActionResult Index()        &#123;            return View();        &#125;    &#125;&#125;\n\n新建Index视图\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        * &#123;            padding: 0;            margin: 0;        &#125;        html &#123;            height: 100%;        &#125;        body &#123;            background-image: linear-gradient(to bottom right, rgb(114, 135, 254), rgb(130, 88, 186));        &#125;        .login-container &#123;            width: 600px;            /*  height: 315px; */            margin: 0 auto;            margin-top: 10%;            border-radius: 15px;            box-shadow: 0 10px 50px 0px rbg(59, 45, 159);            background-color: rgb(95, 76, 194);        &#125;        .left-container &#123;            display: inline-block;            width: 330px;            border-top-left-radius: 15px;            border-bottom-left-radius: 15px;            padding: 60px;            background-image: linear-gradient(to bottom right, rgb(118, 76, 163), rgb(92, 103, 211));        &#125;        .title &#123;            color: #fff;            font-size: 18px;            font-weight: 200;        &#125;            .title span &#123;                border-bottom: 3px solid rgb(237, 221, 22);            &#125;        .input-container &#123;            padding: 20px 0;        &#125;        input &#123;            border: 0;            background: none;            outline: none;            color: #fff;            margin: 20px 0;            display: block;            width: 100%;            padding: 5px 0;            transition: .2s;            border-bottom: 1px solid rgb(199, 191, 219);        &#125;            input:hover &#123;                border-bottom-color: #fff;            &#125;        ::-webkit-input-placeholder &#123;            color: rgb(199, 191, 219);        &#125;        .right-container &#123;            width: 145px;            display: inline-block;            height: calc(100% - 120px);            vertical-align: top;            padding: 60px 0;        &#125;        .action-container &#123;            font-size: 10px;            color: #fff;            text-align: center;            position: relative;            top: 200px;        &#125;            .action-container .btn &#123;                border: 1px solid rgb(237, 221, 22);                padding: 10px;                display: inline;                line-height: 20px;                border-radius: 20px;                position: absolute;                bottom: 10px;                left: calc(72px - 20px);                transition: .2s;                cursor: pointer;            &#125;                .action-container .btn:hover &#123;                    background-color: rgb(237, 221, 22);                    color: rgb(95, 76, 194);                &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;login-container&quot;&gt;        &lt;div class=&quot;left-container&quot;&gt;            &lt;div class=&quot;title&quot;&gt;&lt;span&gt;登录&lt;/span&gt;&lt;/div&gt;            &lt;div class=&quot;input-container&quot;&gt;                &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;用户名&quot;&gt;                &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密码&quot;&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;right-container&quot;&gt;            &lt;div class=&quot;action-container&quot;&gt;                &lt;button type=&quot;submit&quot; id=&quot;login-btn&quot; class=&quot;btn btn-primary&quot;&gt;登录&lt;/button&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script src=&quot;https://code.jquery.com/jquery-3.6.0.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    $(document).ready(function () &#123;        // 当表单提交时        $(&#x27;#login-btn&#x27;).click(function (event) &#123;            event.preventDefault(); // 防止页面刷新            //$(&#x27;.error&#x27;).remove(); // 移除已有的错误信息            var username = $(&#x27;#username&#x27;).val();            var password = $(&#x27;#password&#x27;).val();            // 发起 AJAX 请求            $.ajax(&#123;                type: &#x27;get&#x27;,                contentType: &quot;application/json&quot;,                url: &#x27;@ViewBag.Url/api/Login/UserLogin?username=123&amp;password=456&#x27;,//登录接口地址                // data: JSON.stringify(&#123;                //     username: username,                //     password: password                // &#125;),                success: function (response) &#123;                    window.location.href = &#x27;/swagger&#x27;;                &#125;,                error: function (response) &#123;                    // 如果返回错误信息，则显示在页面上                    const exampleModal = document.getElementById(&#x27;exampleModal&#x27;)                    exampleModal.addEventListener(&#x27;show.bs.modal&#x27;, event =&gt; &#123;                        // Update the modal&#x27;s content.                        const modalTitle = exampleModal.querySelector(&#x27;.modal-title&#x27;);                        const modalBodyInput = exampleModal.querySelector(&#x27;.modal-body&#x27;);                        modalBodyInput.textContent = response?.responseJSON?.result?.error ?? &#x27;服务器异常&#x27;;                    &#125;)                    $(&#x27;#whatever&#x27;).trigger(&#x27;click&#x27;);                &#125;            &#125;);        &#125;);    &#125;);&lt;/script&gt;\n\n请求登录接口成功之后就会自动跳转Swagger，在调用接口时会自动加到请求头，token过期后会跳回登录页面。\n不开登录页，但需要权限校验123456var conifg = new SwaggerConfigParam()&#123;//其他配置EnableSimpleToken=trueEnableLoginPage=false&#125;;\n\n\n","slug":"动态API集成","date":"2024-11-27T00:00:00.000Z","categories_index":".Net","tags_index":".Net,Swagger","author_index":"FaceMan"},{"id":"61d5ab16d3669ffca8733aef334b5fbf","title":"Switch模拟器-YuZu","content":"一般工作吃午饭的时候，我喜欢打开B站找个下饭直播看看，一般会选择塞尔达主播王薯条，有一天突然看到一条弹幕在问主播用的模拟器还是主机，这让我产生了兴趣，于是在某一天摸鱼的时候折腾开始！\n资源+教程PC端解压之后用管理员运行，密钥是已经安装好了的，下好游戏，设置游戏文件夹开玩就行，记得提前设置中文。\n设置软件语言：模拟-》设置-》通用-》界面-》界面语言\n设置游戏语言：模拟-》设置-》系统-》Language和Region\n链接：（填充百度网盘域名，自删）&#x2F;s&#x2F;1WOxIM2-TfkibbgJZ4o7Qjw?pwd&#x3D;1234提取码：1234\n安卓因为我用的是阿里云盘，他没有办法过多文件和zip文件，所以我这里就贴一下大神的。\n资源：yuzu、Skyline、Cemu、Citra、Vita3k、AetherSX2、PPSSPP模拟器 和 开源驱动下载\n教程：教你手机变switch！安卓yuzu模拟器最强保姆级安装使用教程\n游戏资源渠道一：贴吧\n贴吧里很多大神老哥整理的很好，你可以到那里去找资源\n渠道二：VX公众号\n\n电玩联盟\n鹿枫堂游戏\nNS头号电玩\nNS头号玩家\n\n渠道三：网页\n\nSwitch520（switch520最新）\n玩家聚会的网站 - Powered by Discuz!（91最新网站，需要一些签到积分）\nnsboy（冷门论坛）\nSwitch618（类似520）\nRuTracker.org（毛子最大论坛，有时候不需要梯＋注册＋翻译）\n\n","slug":"yuzu","date":"2024-11-26T00:00:00.000Z","categories_index":"日常","tags_index":"生活随笔,Swtich","author_index":"FaceMan"},{"id":"e39417a60f2c78600e5ff58d1d0519aa","title":"使用Hugo搭建个人博客","content":"先来说说写这篇博客的缘由\n一个程序员最好的门面是啥？除了github拥有star数高的开源项目之外当然是个人博客，无论是技术积累还是找工作，有一个属于自己的个人博客无疑是加分项，现在github上有各种开源的博客系统，优点是功能很多，但都有个问题就是大，我之前用Java的oneblog项目部署了一个博客，但由于我是买的阿里云2核2g服务器，部署上去之后由于太大系统崩了，我重启了3次才在docker重启之前关掉，就很尴尬。后面想了个办法是部署到自己的电脑的虚拟机上，然后通过frp+nginx映射出去，但问题又来了，我是笔记本没有办法保证像服务器一样一直运行着，于是，我摆烂了。后面刷B站的时候看到了数字游牧人的一个视频，了解到了hugo这个东西，于是我琢磨了一天弄了个博客出来，踩了一些坑，所以有了今天这篇文章，补充完整给新手小白们避坑。\n必要条件安装和部署网上教程很多，我这里就不多赘述了。\n在github.io安装部署个人博客hugo\nTips1.自定义域名前提：需要有一个自己的域名，如果想以https访问还需要配置证书。\n如果不想用github.io做结尾，可以到github项目的Page页设置自域名（Custom domain），然后在域名服务商那里添加解析记录，解析类型选择CNAME，主机记录填@，记录值填你的github.io的域名，保存即可。我因为解析的是泛域名，然后又用的二级域名所以我用nginx做了一次转发，不这么做nginx配置可以忽略。\n1.配置nginx代理123456789101112131415161718192021222324error_log /var/log/nginx/error.log;    server &#123;        listen 80;        listen 443 ssl;        server_name blog.faceman.cn; # 你的域名        ssl_protocols TLSv1.2 TLSv1.1 TLSv1;           ssl_certificate      /domains/fullchain.pem; # 证书位置        ssl_certificate_key  /domains/key.key; # 证书位置        ssl_prefer_server_ciphers on;         ssl_session_timeout  5m;        if ($server_port = 80) &#123;        rewrite ^(.*)$ https://$host$1 permanent;        &#125;        location / &#123;            proxy_pass https://faceman0814.github.io; # 映射地址            proxy_set_header Host $host;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            root /home/web/;            index index.php;        &#125;    &#125;\n\n重启nginx即可\n2.设置自域名\n2.部署脚本为了简化部署流程，我写了一套Windows版本的脚本分享给大家\n12345678910111213141516171819202122232425262728param(    [string]$commitMessage = &quot;博客更新&quot;)# 输出部署更新信息Write-Host &quot;正在部署到GitHub...&quot; -ForegroundColor Green# 构建项目&amp; hugo# 进入Public文件夹Set-Location public# 将更改添加到gitgit add .# 提交更改Write-Host $commitMessage -ForegroundColor Greengit commit -m $commitMessage# 拉取最新的远程仓库更改以避免冲突git pull origin main# 推送源和构建仓库git push origin main# 返回到项目根目录Set-Location ..\n\n根目录下面保存为deploy.ps1(powershell脚本格式)\n12//在根目录下运行/deploy.ps1 &quot;提交内容&quot; //默认提交内容为博客更新\n\n我用的ananke主题有些小问题，比如：\n\ngithub地址生成的时候会有些乱码导致跳转404\n静态图片部署的时候会被损坏\n\n我在脚本处理，如果你们没有这个问题可以略过。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849param(    [string]$commitMessage = &quot;博客更新&quot;)# 输出部署更新信息Write-Host &quot;正在部署到GitHub...&quot; -ForegroundColor Green# 构建项目&amp; hugo# 进入Public文件夹Set-Location public# 扫描所有文件并替换指定字符串$replacements = @&#123;    &quot;https://github.com/faceman0814%25!%28EXTRA%20%3cnil%3e%29&quot; = &quot;https://github.com/faceman0814&quot;;&#125;# 扫描所有文件并替换指定字符串Get-ChildItem -Recurse | Where-Object &#123; !$_.PSIsContainer &#125; | ForEach-Object &#123;    $content = Get-Content $_.FullName -Raw    foreach ($oldText in $replacements.Keys) &#123;        $newText = $replacements[$oldText]        $content = $content -replace [regex]::Escape($oldText), $newText    &#125;    Set-Content $_.FullName -Value $content&#125;# 复制 images 文件夹，使用相对路径回退到根目录再访问static/images$sourcePath = &quot;..\\static\\images&quot;$destinationPath = &quot;.\\images&quot;Copy-Item -Path $sourcePath\\* -Destination $destinationPath -Force -Recurse# 将更改添加到gitgit add .# 提交更改Write-Host $commitMessage -ForegroundColor Greengit commit -m $commitMessage# 拉取最新的远程仓库更改以避免冲突git pull origin main# 推送源和构建仓库git push origin main# 返回到项目根目录Set-Location ..\n\n页脚加运行时间在页脚加入代码\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;div class=&quot;footer-container&quot;&gt;      &lt;span id=&quot;sitetime&quot;&gt;载入运行时间...&lt;/span&gt; &lt;/div&gt;&lt;script&gt;  function siteTime() &#123;      var seconds = 1000;      var minutes = seconds * 60;      var hours = minutes * 60;      var days = hours * 24;      var years = days * 365;      var today = new Date();      var startYear = 2024;      var startMonth = 11;      var startDate = 8;      var startHour = 14;      var startMinute = 15;      var startSecond = 11;      var todayYear = today.getFullYear();      var todayMonth = today.getMonth() + 1;      var todayDate = today.getDate();      var todayHour = today.getHours();      var todayMinute = today.getMinutes();      var todaySecond = today.getSeconds();      var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);      var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);      var diff = t2 - t1;      var diffYears = Math.floor(diff / years);      var diffDays = Math.floor((diff / days) - diffYears * 365);      var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);      var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /          minutes);      var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -          diffMinutes * minutes) / seconds);      if (startYear == todayYear) &#123;          //document.getElementById(&quot;year&quot;).innerHTML = todayYear;          document.getElementById(&quot;sitetime&quot;).innerHTML = &quot;博客已运行 &quot; + diffDays + &quot; 天 &quot; + diffHours +              &quot; 小时 &quot; + diffMinutes + &quot; 分钟 &quot; + diffSeconds + &quot; 秒&quot;;      &#125; else &#123;          //document.getElementById(&quot;year&quot;).innerHTML = startYear + &quot; - &quot; + todayYear;          document.getElementById(&quot;sitetime&quot;).innerHTML = &quot;博客已运行 &quot; + diffYears + &quot; 年 &quot; + diffDays +              &quot; 天 &quot; + diffHours + &quot; 小时 &quot; + diffMinutes + &quot; 分钟 &quot; + diffSeconds + &quot; 秒&quot;;      &#125;  &#125;  setInterval(siteTime, 1000);&lt;/script&gt;\n\n添加访问量计数工具1234567&lt;script async src=&quot;https://busuanzi.icodeq.com/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;本文总阅读量 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次本站总访问量 &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; 次本站总访客数 &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; 人\n\n遇到的一些坑中文博客内容截断过长默认情况下，Hugo 可能会根据单词边界来截断摘要，这在处理英文时比较合适，但对于中文等没有明显空格分隔的语言则不太适用。就可能会导致摘要部分过长，导致观感不好，面对这种情况有两个解决方案。\n方案 1：自定义 Summary 分隔符你可以在文章中手动定义一个分隔符来指示摘要结束的位置。例如，在 Markdown 文件中使用&lt;!--more--&gt;标签来定义摘要的结束。\n方案 2：调整 .Summary 长度如果不希望在每篇文章中手动加入分隔符，你可以通过配置文件来全局调整摘要的长度。配置文件（config.toml）示例：\n12[summary]  length = 120  # 控制摘要的字符数，默认是 70\n\n这样设置后，Hugo 将会自动截取每篇文章的前 120 个字符作为摘要。\n方案 3：使用 CSS 控制显示内容如果你仍然想在前端控制显示的文字数量（尤其是为了保持布局的一致性），可以使用 CSS 的 text-overflow 属性。\n1234567.nested-copy-line-height &#123;  display: -webkit-box;  -webkit-box-orient: vertical;  -webkit-line-clamp: 3; /* 限制在3行内 */  overflow: hidden;  text-overflow: ellipsis;&#125;\n\n以上方法可以选择适合你网站需求的一种或几种结合起来使用。如果选择 CSS 方式，请确保它不会影响用户体验和内容的可访问性。\n","slug":"使用Hugo搭建个人博客","date":"2024-11-26T00:00:00.000Z","categories_index":"DevOps","tags_index":"Hugo","author_index":"FaceMan"},{"id":"82af2d180e848d28b222db96dd62b1e7","title":"动态API集成源码解析版","content":"在日常开发时，想要用到Swagger就必须得创建控制器创建接口文档，一般业务处理都不会在控制器中处理，我们一般会再创建另一个类来处理业务逻辑，每次创建都两个类就很繁琐，这篇文章就是为了解决这个繁琐，代码只讲了大概思路，具体的细节可以参考源码!动态API仓库。不关心源码的朋友可以直接集成我的Nuget包FaceMan.DynamicAPI，配置教程参考我的文章：动态API集成。\n集成Swagger\n首先，在你的.NET Core项目中安装需要的包。你可以通过NuGet包管理器来安装它，也可以直接复制粘贴安装，以下是包名和版本。\n\n12&lt;PackageReference Include=&quot;Swashbuckle.AspNetCore&quot; Version=&quot;6.4.0&quot; /&gt;&lt;PackageReference Include=&quot;Swashbuckle.AspNetCore.Filters&quot; Version=&quot;8.0.2&quot; /&gt;\n\n\n.Net 6以后取消了StartUp，配置都在Program中，这里采用新写法。\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var builder = WebApplication.CreateBuilder(args);// 配置文件读取var basePath = AppContext.BaseDirectory;var config = new ConfigurationBuilder()                .SetBasePath(basePath)                .AddJsonFile(&quot;appsettings.json&quot;, optional: true, reloadOnChange: true)                .Build();  #region 添加Swagger文档服务builder.Services.AddEndpointsApiExplorer();builder.Services.AddSwaggerGen(options =&gt;&#123;    //添加响应头信息。它可以帮助开发者查看 API 响应中包含的 HTTP 头信息，从而更好地理解 API 的行为。    options.OperationFilter&lt;AddResponseHeadersFilter&gt;();    //摘要中添加授权信息。它会在每个需要授权的操作旁边显示一个锁图标，提醒开发者该操作需要身份验证。    options.OperationFilter&lt;AppendAuthorizeToSummaryOperationFilter&gt;();    //加安全需求信息。它会根据 API 的安全配置（如 OAuth2、JWT 等）自动生成相应的安全需求描述，帮助开发者了解哪些操作需要特定的安全配置。    options.OperationFilter&lt;SecurityRequirementsOperationFilter&gt;();    options.SwaggerDoc(&quot;v1&quot;, new OpenApiInfo    &#123;        Title = &quot;xxxFrameWork API&quot;,        Version = &quot;v1&quot;,        Description = &quot;xxxFrameWork API 接口文档&quot;,        Contact = new OpenApiContact()        &#123;            Name = &quot;xxxxx&quot;,            Email = &quot;xxxxx@qq.com&quot;,            Url = new Uri(&quot;https://github.com/xxxxx&quot;)        &#125;    &#125;);&#125;);#endregion 添加Swagger文档服务//开发环境才开启文档。if (app.Environment.IsDevelopment())&#123;    app.UseSwagger();    app.UseSwaggerUI(options =&gt;    &#123;        //配置Endpoint路径和文档标题        options.SwaggerEndpoint(&quot;/swagger/v1/swagger.json&quot;, &quot;v1 Docs&quot;);        //配置路由前缀，RoutePrefix是Swagger UI的根路径。        //options.RoutePrefix = String.Empty;        //设置默认模型展开深度。默认值为3，可以设置成-1以完全展开所有模型。        //options.DefaultModelExpandDepth(-1);        // 启用深链接功能后，用户可以直接通过URL访问特定的API操作或模型，而不需要手动导航到相应的位置。        options.EnableDeepLinking();        options.DocExpansion(DocExpansion.None); //swagger文档展开方式，none为折叠，list为列表    &#125;);&#125;\n\n动态APISwagger文档的原理是扫描控制器来生成，动态API则是自定义类控制器，然后让接口继承，自定义控制器识别规则，实现思路：\n\n定义一个接口或特性用来标识这是个控制器，Mvc中实现的核心是ControllerFeatureProvider类，重写IsController的判断逻辑。\n继承IApplicationModelConvention重写Apply，如果是继承了自定义的控制器接口就根据规则标记Http请求类型。比如Abp中继承了IApplicationService接口，Swagger会自动识别,且遵循约定大于规范原则，将Get开头的请求都默认是Get请求，Del开头的请求默认是Delete请求。\n配置应用程序部分管理器，添加自定义的控制器特性提供程序\n配置MvcOptions，添加自定义的应用程序模型约定\n\n模仿Abp的实现\n创建IApplicationService用来标识自定义控制器的接口或特性1234567891011121314/// &lt;summary&gt;/// 动态WebAPI接口/// &lt;/summary&gt;public class IApplicationService&#123;&#125; /// &lt;summary&gt; /// 动态WebAPI特性 /// &lt;/summary&gt; [AttributeUsage(AttributeTargets.Class, Inherited = true)] public class DynamicWebApiAttribute : Attribute &#123; &#125;\n\n创建ApplicationServiceControllerFeatureProvider类来继承ControllerFeatureProvider类\n1234567891011121314151617181920212223242526272829/// &lt;summary&gt;/// 自定义控制器特性提供程序，用于将实现了 IApplicationService 接口的类识别为控制器。/// &lt;/summary&gt;public class ApplicationServiceControllerFeatureProvider : ControllerFeatureProvider&#123;    /// &lt;summary&gt;    /// 判断给定的类型是否为控制器。    /// &lt;/summary&gt;    /// &lt;param name=&quot;typeInfo&quot;&gt;要判断的类型信息。&lt;/param&gt;    /// &lt;returns&gt;如果类型是控制器，则返回 true；否则返回 false。&lt;/returns&gt;    protected override bool IsController(TypeInfo typeInfo)    &#123;        // 检查类型是否实现了 IApplicationService 接口        if (typeof(IApplicationService).IsAssignableFrom(typeInfo))        &#123;            // 检查类型是否满足以下条件：            var type = typeInfo.AsType();            if ((typeof(IApplicationService).IsAssignableFrom(type) || //判断是否继承ICoreDynamicController接口                type.IsDefined(typeof(DynamicWebApiAttribute), true) ||// 判断是否标记了DynamicAPIAttribute特性                 type.BaseType == typeof(Controller)) &amp;&amp;                typeInfo.IsPublic &amp;&amp; !typeInfo.IsAbstract &amp;&amp; !typeInfo.IsGenericType &amp;&amp; !typeInfo.IsInterface)//必须是Public、不能是抽象类、必须是非泛型的            &#123;                return true;            &#125;        &#125;        // 如果不满足上述条件，则返回 false        return false;    &#125;&#125;\n\n创建HttpMethodConfigure配置类12345public class HttpMethodConfigure   &#123;       public string MethodKey &#123; get; set; &#125;       public List&lt;string&gt; MethodVal &#123; get; set; &#125;   &#125;\n\n创建ApplicationServiceConvention继承IApplicationModelConvention123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140/// &lt;summary&gt;/// 自定义应用程序模型约定，用于配置实现了 IApplicationService 接口的控制器。/// &lt;/summary&gt;public class ApplicationServiceConvention : IApplicationModelConvention&#123;    private IConfiguration _configuration;    private List&lt;HttpMethodConfigure&gt; httpMethods = new();    public ApplicationServiceConvention(IConfiguration configuration)    &#123;        _configuration = configuration;        httpMethods = _configuration.GetSection(&quot;HttpMethodInfo&quot;).Get&lt;List&lt;HttpMethodConfigure&gt;&gt;();    &#125;    /// &lt;summary&gt;    /// 应用约定    /// &lt;/summary&gt;    /// &lt;param name=&quot;application&quot;&gt;&lt;/param&gt;    public void Apply(ApplicationModel application)    &#123;        //循环每一个控制器信息        foreach (var controller in application.Controllers)        &#123;            var controllerType = controller.ControllerType.AsType();            //是否继承IApplicationService接口            if (typeof(IApplicationService).IsAssignableFrom(controllerType))            &#123;                //Actions就是接口的方法                foreach (var item in controller.Actions)                &#123;                    ConfigureSelector(controller.ControllerName, item);                &#125;            &#125;        &#125;    &#125;    /// &lt;summary&gt;    /// 配置选择器    /// &lt;/summary&gt;    /// &lt;param name=&quot;controllerName&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;action&quot;&gt;&lt;/param&gt;    private void ConfigureSelector(string controllerName, ActionModel action)    &#123;        //如果属性路由模型为空，则移除        for (int i = 0; i &lt; action.Selectors.Count; i++)        &#123;            if (action.Selectors[i].AttributeRouteModel is null)            &#123;                action.Selectors.Remove(action.Selectors[i]);            &#125;        &#125;            //去除路径中的AppService后缀            if (controllerName.EndsWith(&quot;AppService&quot;))            &#123;                controllerName = controllerName.Substring(0, controllerName.Length - 10);            &#125;        //如果有选择器，则遍历选择器，添加默认路由        if (action.Selectors.Any())        &#123;            foreach (var item in action.Selectors)            &#123;                var routePath = string.Concat(&quot;api/&quot;, controllerName + &quot;/&quot;, action.ActionName).Replace(&quot;//&quot;, &quot;/&quot;);                var routeModel = new AttributeRouteModel(new RouteAttribute(routePath));                //如果没有设置路由，则添加路由                if (item.AttributeRouteModel == null)                &#123;                    item.AttributeRouteModel = routeModel;                &#125;            &#125;        &#125;        //如果没有选择器，则创建一个选择器并添加。        else        &#123;            action.Selectors.Add(CreateActionSelector(controllerName, action));        &#125;    &#125;    /// &lt;summary&gt;    /// 创建Action选择器    /// &lt;/summary&gt;    /// &lt;param name=&quot;controllerName&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;action&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    private SelectorModel CreateActionSelector(string controllerName, ActionModel action)    &#123;        var selectorModel = new SelectorModel();        var actionName = action.ActionName;        string httpMethod = string.Empty;        //是否有HttpMethodAttribute        var routeAttributes = action.ActionMethod.GetCustomAttributes(typeof(HttpMethodAttribute), false);        //如果标记了HttpMethodAttribute        if (routeAttributes != null &amp;&amp; routeAttributes.Any())        &#123;            httpMethod = routeAttributes.SelectMany(m =&gt; (m as HttpMethodAttribute).HttpMethods).ToList().Distinct().FirstOrDefault();        &#125;        else        &#123;            //大写方法名            var methodName = action.ActionMethod.Name.ToUpper();            //遍历HttpMethodInfo配置，匹配方法名            foreach (var item in httpMethods)            &#123;                foreach (var method in item.MethodVal)                &#123;                    if (methodName.StartsWith(method))                    &#123;                        httpMethod = item.MethodKey;                        break;                    &#125;                &#125;            &#125;            //如果没有找到对应的HttpMethod，默认使用POST            if (httpMethod == string.Empty)            &#123;                httpMethod = &quot;POST&quot;;            &#125;        &#125;        return ConfigureSelectorModel(selectorModel, action, controllerName, httpMethod);    &#125;    /// &lt;summary&gt;    /// 配置选择器模型    /// &lt;/summary&gt;    /// &lt;param name=&quot;selectorModel&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;action&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;controllerName&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;httpMethod&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public SelectorModel ConfigureSelectorModel(SelectorModel selectorModel, ActionModel action, string controllerName, string httpMethod)    &#123;        var routePath = string.Concat(&quot;api/&quot;, controllerName + &quot;/&quot;, action.ActionName).Replace(&quot;//&quot;, &quot;/&quot;);        //给此选择器添加路由        selectorModel.AttributeRouteModel = new AttributeRouteModel(new RouteAttribute(routePath));        //添加HttpMethod        selectorModel.ActionConstraints.Add(new HttpMethodActionConstraint(new[] &#123; httpMethod &#125;));        return selectorModel;    &#125;&#125;\n\n创建DynamicWebApiExtensions1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/// &lt;summary&gt;/// 动态WebAPI扩展类，用于在ASP.NET Core应用程序中添加动态WebAPI功能。/// &lt;/summary&gt;public static class DynamicWebApiExtensions&#123;    /// &lt;summary&gt;    /// 为IMvcBuilder添加动态WebAPI功能。    /// &lt;/summary&gt;    /// &lt;param name=&quot;builder&quot;&gt;IMvcBuilder实例。&lt;/param&gt;    /// &lt;returns&gt;IMvcBuilder实例。&lt;/returns&gt;    public static IMvcBuilder AddDynamicWebApi(this IMvcBuilder builder, IConfiguration configuration)    &#123;        if (builder == null)        &#123;            throw new ArgumentNullException(nameof(builder));        &#125;        // 配置应用程序部分管理器，添加自定义的控制器特性提供程序        builder.ConfigureApplicationPartManager(applicationPartManager =&gt;        &#123;            applicationPartManager.FeatureProviders.Add(new ApplicationServiceControllerFeatureProvider());        &#125;);        // 配置MvcOptions，添加自定义的应用程序模型约定        builder.Services.Configure&lt;MvcOptions&gt;(options =&gt;        &#123;            options.Conventions.Add(new ApplicationServiceConvention(configuration));        &#125;);        return builder;    &#125;    /// &lt;summary&gt;    /// 为IMvcCoreBuilder添加动态WebAPI功能。    /// &lt;/summary&gt;    /// &lt;param name=&quot;builder&quot;&gt;IMvcCoreBuilder实例。&lt;/param&gt;    /// &lt;returns&gt;IMvcCoreBuilder实例。&lt;/returns&gt;    public static IMvcCoreBuilder AddDynamicWebApi(this IMvcCoreBuilder builder, IConfiguration configuration)    &#123;        if (builder == null)        &#123;            throw new ArgumentNullException(nameof(builder));        &#125;        // 配置应用程序部分管理器，添加自定义的控制器特性提供程序        builder.ConfigureApplicationPartManager(applicationPartManager =&gt;        &#123;            applicationPartManager.FeatureProviders.Add(new ApplicationServiceControllerFeatureProvider());        &#125;);        // 配置MvcOptions，添加自定义的应用程序模型约定        builder.Services.Configure&lt;MvcOptions&gt;(options =&gt;        &#123;            options.Conventions.Add(new ApplicationServiceConvention(configuration));        &#125;);        return builder;    &#125;&#125;\n\nProgram中配置123456//注册动态API服务builder.Services.AddControllers().AddDynamicWebApi(builder.Configuration);//必须要加，不然断点进不来app.MapControllers();\n\n在Appsettings配置http请求类型匹配规则123456789101112131415161718&quot;HttpMethodInfo&quot;: [  &#123;    &quot;MethodKey&quot;: &quot;Get&quot;,    &quot;MethodVal&quot;: [ &quot;GET&quot;, &quot;QUERY&quot; ]  &#125;,  &#123;    &quot;MethodKey&quot;: &quot;Post&quot;,    &quot;MethodVal&quot;: [ &quot;CREATE&quot;, &quot;SAVE&quot;, &quot;INSERT&quot;, &quot;ADD&quot; ]  &#125;,  &#123;    &quot;MethodKey&quot;: &quot;Put&quot;,    &quot;MethodVal&quot;: [ &quot;UPDATE&quot;, &quot;EDIT&quot; ]  &#125;,  &#123;    &quot;MethodKey&quot;: &quot;Delete&quot;,    &quot;MethodVal&quot;: [ &quot;Delete&quot;, &quot;REMOVE&quot; ]  &#125;]\n\n创建测试类12345678910111213141516public class Test : IApplicationService&#123;    /// &lt;summary&gt;    ///领域层注释测试接口    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public string Hello()    &#123;        return &quot;Hello from Class1&quot;;    &#125;    public string Get()    &#123;        return &quot;Get from Class1&quot;;    &#125;&#125;\n\n\n将动态API配置Swagger文档注释\n类库配置中设置xml文件生成地址\n\n12&lt;GenerateDocumentationFile&gt;True&lt;/GenerateDocumentationFile&gt;&lt;DocumentationFile&gt;bin\\Debug\\FlyFramework.Core.xml&lt;/DocumentationFile&gt;\n\n\n在Host中的wwwroot创建ApiDocs文件夹\nHost主机配置xml文件复制地址，生成的xml文件会复制到对应的地址。\n\n123456789101112131415161718&lt;ApiDocDir&gt;wwwroot\\ApiDocs&lt;/ApiDocDir&gt;&lt;!--在构建项目后，复制所有以FlyFramework开头的XML文档文件到指定的API文档目录。这通常用于将生成的XML文档文件（例如API注释）整理到一个目录中，便于进一步的处理或发布。这种做法可以适合于生成API文档如Swagger时的使用场景。--&gt;&lt;Target Name=&quot;CopyXmlDocFileForBuild&quot; AfterTargets=&quot;Build&quot;&gt;\t&lt;ItemGroup&gt;\t\t&lt;!--Include=&quot;@(ReferencePath-&gt;&#x27;%(RootDir)%(Directory)%(Filename).xml&#x27;)&quot;：这行表示从所有项目引用（ReferencePath）的路径中收集以.xml为扩展名的文件。这些文件通常是生成的XML文档文件。--&gt;\t\t&lt;!--Condition=&quot;$([System.String]::new(&#x27;%(FileName)&#x27;).StartsWith(&#x27;FlyFramework&#x27;))&quot;：此条件用于过滤文件，仅包括文件名以FlyFramework开头的XML文档文件。这保证只有相关的文档文件被选择。--&gt;\t\t&lt;XmlDocFiles Include=&quot;@(ReferencePath-&gt;&#x27;%(RootDir)%(Directory)%(Filename).xml&#x27;)&quot; Condition=&quot;$([System.String]::new(&#x27;%(FileName)&#x27;).StartsWith(&#x27;FlyFramework&#x27;))&quot; /&gt;\t&lt;/ItemGroup&gt;\t&lt;!--SourceFiles=&quot;@(XmlDocFiles)&quot;：指定要复制的源文件为上一步中定义的XmlDocFiles集合。--&gt;\t&lt;!--`Condition=&quot;Exists(&#x27;%(FullPath)&#x27;)&quot;：确保复制前源文件存在，这是一种安全检查。--&gt;\t&lt;!--DestinationFolder=&quot;$(ApiDocDir)&quot;：目的地文件夹为$(ApiDocDir)，这个属性之前已经在项目文件中定义，指向存放API文档的目录。--&gt;\t&lt;!--SkipUnchangedFiles=&quot;true&quot;：此选项表示只有发生变化的文件会被复制，这可以提高效率，避免不必要的复制操作。--&gt;\t&lt;Copy SourceFiles=&quot;@(XmlDocFiles)&quot; Condition=&quot;Exists(&#x27;%(FullPath)&#x27;)&quot; DestinationFolder=&quot;$(ApiDocDir)&quot; SkipUnchangedFiles=&quot;true&quot; /&gt;&lt;/Target&gt;\n\n\n在AddSwaggerGen增加配置\n\n12345678//遍历所有xml并加载var binXmlFiles =    new DirectoryInfo(Path.Join(builder.Environment.WebRootPath, &quot;ApiDocs&quot;))        .GetFiles(&quot;*.xml&quot;, SearchOption.TopDirectoryOnly);foreach (var filePath in binXmlFiles.Select(item =&gt; item.FullName))&#123;    options.IncludeXmlComments(filePath, true);&#125;\n\n致谢思路参考的大佬文章，大佬是从源码角度解释，我写这篇偏新手向，做了些拓展，原文指路：.Net Core后端架构实战【2-实现动态路由与Dynamic API】 - 江北、 - 博客园 (cnblogs.com)\n","slug":"动态API集成源码解析版","date":"2024-11-24T00:00:00.000Z","categories_index":".Net","tags_index":"Swagger","author_index":"FaceMan"},{"id":"26f6a1758883b55cdee304c67b5f3a44","title":".NetCore自动开启事务保证数据一致性","content":"起因是因为公司没有使用任何代码框架，所以使用的都是比较原始的写法，在系统的各处都有SaveChanges()方法,这样会产生一个问题就是，如果出现异常前面已经执行了一些操作直接到数据库去了，但应该回滚到之前的状态，所以我们需要手动开启事务，并在方法执行完毕后提交事务。但是如果每个方法都手动开启事务，代码会显得很冗余，所以我们需要一个自动开启事务的机制。\n实现方法同步方法12345678910111213141516171819202122232425262728293031public class TransactionFilterAttritube : IActionFilter&#123;    private readonly YourDbContext  _dbContext;    public TransactionFilterAttritube(YourDbContext  dbContext)    &#123;        _dbContext = dbContext;    &#125;    public void OnActionExecuted(ActionExecutedContext context)    &#123;        // 检查是否有异常发生        if (context.Exception == null &amp;&amp; !context.Canceled)        &#123;            // 提交事务            _dbContext.SaveChanges();            _dbContext.Database.CurrentTransaction?.Commit();        &#125;        else        &#123;            // 回滚事务            _dbContext.Database.CurrentTransaction?.Rollback();        &#125;    &#125;    public void OnActionExecuting(ActionExecutingContext context)    &#123;        // 在动作方法执行之前启动事务        _dbContext.Database.BeginTransaction();    &#125;&#125;\n\n异步方法12345678910111213141516171819202122232425262728public class TransactionFilterAttritube : IAsyncActionFilter&#123;    private readonly YourDbContext  _dbContext;    public TransactionFilterAttritube(YourDbContext  dbContext)    &#123;        _dbContext = dbContext;    &#125;    public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)    &#123;        // 在动作方法执行之前启动事务        var transaction = await _dbContext.Database.BeginTransactionAsync();        var executedContext = await next(); // 执行Action        // 检查是否有异常发生        if (executedContext.Exception == null)        &#123;            // 提交事务            await _dbContext.SaveChangesAsync();            await transaction.CommitAsync();        &#125;        else        &#123;            // 回滚事务            await transaction.RollbackAsync();        &#125;    &#125;&#125;\n\n使用方法启动时注册拦截器：\n1234services.AddMvcCore(option =&gt;&#123;    option.Filters.Add&lt;TransactionFilterAttritube&gt;();&#125;)\n\n总结通过拦截器的方式，我们可以自动开启事务，并在方法执行完毕后提交事务，避免手动开启事务，提高代码的可读性和可维护性。\n","slug":"NetCore自动开启事务","date":"2024-11-22T00:00:00.000Z","categories_index":".Net","tags_index":".NetCore,c#","author_index":"FaceMan"},{"id":"1796052fe66afe402255c3eb4319b228","title":"Sql优化方法","content":"最近新入职了一家电商公司，做CRM系统，由于业务量比较大，数据量庞大动不动几十万数据起步，数据库的压力也很大。比如最近遇到的需求，需要查看最规定时间内客户是否有下单，或者是否有跟客户联系，如果没有的话就要释放出去，这就需要去订单表查询他的下单记录和联系记录。联系记录好查，有定时同步最后一次联系时间的，但订单表的数据量大，要查询所有用户的最后一单成交记录就需要分组去查了。我直接写在linq里面查询，速度贼慢，查询了几分钟，还没返回结果。但是我把查询订单这一步单独拿出来做成视图再去连表查询，速度就快多了几秒就出来了。查了下大概原因应该是视图在数据库中被预先编译和优化，所以当通过视图查询数据时，数据库可以快速响应。而直接在EF Core中使用LINQ查询可能会生成不够优化的SQL语句，尤其是涉及到聚合、分组等操作时。所以数据量大且查询性能不好时，也不失为一种优化方法（如果有误请指正）。\n以前数据量小没怎么关注过Sql优化，所以下面记录一些常用的Sql优化方法，以mysql为例。\n1. 避免使用select *很多时候，我们写sql语句时，为了方便，喜欢直接使用select *，一次性查出表中所有列的数据。在实际业务场景中，可能我们真正需要使用的只有其中一两列。查了很多数据，但是不用，白白浪费了数据库资源，比如：内存或者cpu。此外，多查出来的数据，通过网络IO传输的过程中，也会增加数据传输的时间。还有一个最重要的问题是：select *不会走覆盖索引，会出现大量的回表操作，而从导致查询sql的性能很低。\n所以，最佳实践是：只选择需要的列，并且尽量避免使用select *。\n2. 用union all代替unionunion all不会去重，而union会，排重的过程需要遍历、排序和比较，它更耗时，更消耗cpu资源。所以需要去重用union不需要去重的时候用union all。\n3. 小表驱动大表如果sql语句中包含了in关键字，则它会优先执行in里面的子查询语句，然后再执行in外面的语句。如果in里面的数据量很少，作为条件查询速度更快。而如果sql语句中包含了exists关键字，它优先执行exists左边的语句（即主查询语句）。然后把它作为条件，去跟右边的语句匹配。如果匹配上，则可以查询出数据。如果匹配不上，数据就被过滤掉了。\n\nin 适用于左边大表，右边小表。\nexists 适用于左边小表，右边大表。不管是用in，还是exists关键字，其核心思想都是用小表驱动大表。\n\n4. 批量插入批量插入可以提高数据库的插入性能。我们可以把需要插入的数据分批次插入，而不是一条一条插入。这样可以减少网络IO，提高数据库的插入性能。但需要注意的是，不建议一次批量操作太多的数据，如果数据太多数据库响应也会很慢。批量操作需要把握一个度，建议每批数据尽量控制在500以内。如果数据多于500，则分多批次处理。\n5. 多用limitlimit可以限制查询结果的数量，避免查询出大量数据，影响查询效率。比如查询某个用户下的第一个订单，想看看他第一次的首单时间。\n1SELECT order_time FROM orders WHERE user_id = 1 ORDER BY order_time LIMIT 1;\n\n6. in中值太多in中值太多，会导致查询计划变得复杂，索引失效，导致查询效率变低。所以in中值不要太多。\n对于批量查询接口，我们通常会使用in关键字过滤出数据。比如：想通过指定的一些id，批量查询出用户信息，但是如果我们不做任何限制，该查询语句一次性可能会查询出非常多的数据，很容易导致接口超时。所以可以在sql中对数据用limit做限制。\n1SELECT * FROM user_info WHERE id IN (1,2,3,4,5,6,7,8,9,10) LIMIT 10;\n\n还有一个方案就是：如果ids超过500条记录，可以分批用多线程去查询数据。每批只查500条记录，最后把查询到的数据汇总到一起返回。\n7. 增量查询增量查询可以避免全表扫描，只查询新增的数据。比如：我们想查询某个用户的新增订单，只需要查询user_id大于某个值，并且order_time大于某个值的数据。\n1SELECT * FROM orders WHERE user_id &gt; 1000 AND order_time &gt; &#x27;2021-01-01&#x27;;\n\n8. 高效的分页分页查询是数据库查询中最常用的功能之一。分页查询可以提高查询效率，避免查询出大量数据，影响查询效率。\n方案一 limit在mysql中分页一般用的limit关键字，如果表中数据量少，用limit关键字做分页，没啥问题。但如果表中数据量很多，用它就会出现性能问题。比如现在分页参数变成了：\n12select id,name,age from user limit 1000000,20;\n\nmysql会查到1000020条数据，然后丢弃前面的1000000条，只查后面的20条数据，这个是非常浪费资源的。那么，这种海量数据该怎么分页呢？优化sql：\n12select id,name,age from user where id &gt; 1000000 limit 20;\n\n先找到上次分页最大的id，然后利用id上的索引查询。不过该方案，要求id是连续的，并且有序的。\n方案二 between另一种分页方法是利用between关键字，比如：\n12select id,name,age from user where id between 1000000 and 1000020;\n\n需要注意的是between要在唯一索引上分页，不然会出现每页大小不一致的问题。\n9. 用连接查询代替子查询连接查询是一种更高效的查询方式。连接查询可以避免子查询的性能问题。比如：\n12select * from orderwhere user_id in (select id from user where status=1)\n\n子查询会导致大量的回表操作，导致查询效率很低。优化sql：\n123select o.* from order oinner join user u on o.user_id = u.idwhere u.status=1\n\n用连接查询，把子查询结果作为一个表，直接与主表连接，避免了回表操作。\n10. 提升group by的效率我们有很多业务场景需要使用group by关键字，它主要的功能是去重和分组。通常它会跟having一起配合使用，表示分组后再根据一定的条件过滤数据。比如：\n123select user_id,user_name from ordergroup by user_idhaving user_id &lt;= 200;\n\n这种写法性能不好，它先把所有的订单根据用户id分组之后，再去过滤用户id大于等于200的用户。分组是一个相对耗时的操作，为什么我们不先缩小数据的范围之后，再分组呢？优化sql：\n123select user_id,user_name from orderwhere user_id &lt;= 200group by user_id\n\n使用where条件在分组前，就把多余的数据过滤掉了，这样分组时效率就会更高一些。其实这是一种思路，不仅限于group by的优化。我们的sql语句在做一些耗时的操作之前，应尽可能缩小数据范围，这样能提升sql整体的性能。\n11. 索引优化很多时候sql语句，走了索引，和没有走索引，执行效率差别很大。所以索引优化被作为sql优化的首选。索引优化的第一步是：检查sql语句有没有走索引。那么，如何查看sql走了索引没？可以使用explain命令，查看mysql的执行计划。\n1explain select * from user where id = 1;\n\n\nsql语句没有走索引，排除没有建索引之外，最大的可能性是索引失效了。\n此外，你有没有遇到过这样一种情况：明明是同一条sql，只有入参不同而已。有的时候走的索引a，有的时候却走的索引b？没错，有时候mysql会选错索引。必要时可以使用force index来强制查询sql走某个索引。\n","slug":"Sql优化方法","date":"2024-11-21T00:00:00.000Z","categories_index":"数据库","tags_index":"Sql","author_index":"FaceMan"},{"id":"584404787b0b0e754117ced08ab7daf6","title":"NFS for CentOS","content":"NFS for CentOSNFS介绍NFS介绍NFS 即网络文件系统（Network File-System），可以通过网络让不同机器、不同系统之间可以实现文件共享。通过 NFS，可以访问远程共享目录，就像访问本地磁盘一样。NFS 只是一种文件系统，本身并没有传输功能，是基于 RPC（远程过程调用）协议实现的，采用 C&#x2F;S 架构。\n安装目标：实现A共享目录，B访问A。\n前置条件：准备两台主机A和B，且在同一局域网。\n\nA安装NFS软件包\n1sudo yum install nfs-utils\n配置 NFS 服务端\n编辑 /etc/exports 文件，添加需要共享的目录及其权限设置。\n例如，假设我们需要共享 /mnt/data 目录，并且允许所有客户端读写访问：\n1/mnt/data  *(rw,sync,no_root_squashva\n\n其中：\n\n/mnt/data 是需要共享的目录。\n&#96;&#96; 表示允许所有客户端访问。\nrw 表示允许读写访问。\nsync 表示同步写入磁盘，保证数据的安全性。\nno_root_squash 表示允许 root 用户访问共享目录。\n\n保存修改后，使用以下命令重新加载配置：\n1sudo exportfs -r\n启动 NFS 服务端\n使用以下命令启动 NFS 服务端：\n1sudo systemctl start nfs-server\n\n可以使用以下命令检查服务是否已启动：\n1sudo systemctl status nfs-server\nB配置 NFS 客户端\n在B上，安装 NFS 软件包：\n1sudo yum install nfs-utils\n\n然后运行之后，使用以下命令挂载共享目录：\n1sudo mount server:/mnt/data /mnt/nfs\n\n其中：\n\nserver 是 NFS 服务端的 IP 地址或主机名。\n/mnt/data 是共享的目录。\n/mnt/nfs 是挂载到客户端上的目录。\n\n\n5.验证 NFS 服务\n可以在客户端上创建、修改、删除文件，然后在服务端上查看是否同步更新。\n如果需要卸载 NFS 共享目录，可以使用以下命令：\n1sudo umount /mnt/nfs\n\n问题解决mount.nfs: No route to host这个错误通常表示无法到达目标主机。请确保在执行该命令之前，您的机器可以访问目标机器的 IP 地址，并且目标机器上的 NFS 服务正在运行。\n您可以通过以下几种方法来解决这个问题：\n\n检查网络连接\n请检查您的机器与目标机器之间的网络连接，确保它们可以互相访问。您可以尝试使用 ping 命令来测试网络连接，例如：\n1ping 192.168.2.164\n如果无法 ping 通目标机器，可能需要检查您的网络设置或防火墙配置。\n\n检查目标机器的 NFS 服务状态\n请确保目标机器上的 NFS 服务正在运行，并且已正确配置共享目录。您可以尝试在目标机器上使用以下命令检查 NFS 服务状态\n\n检查目标机器的防火墙设置\n如果目标机器的防火墙已启用，请确保已将 NFS 服务端口添加到防火墙规则中。NFS 默认使用 TCP 和 UDP 端口 2049。您可以尝试使用以下命令检查目标机器上的防火墙设置：\n1firewall-cmd --list-all\n如果需要，请添加防火墙规则，例如：\n12firewall-cmd --add-service=nfs --permanentfirewall-cmd --reload\n\n","slug":"NFSforCentOS","date":"2024-11-19T00:00:00.000Z","categories_index":"DevOps","tags_index":"CentOS,Linux","author_index":"FaceMan"},{"id":"d153e7aca8864e461d50ee65cfb7c4b4","title":"c#实现对话记录转PDF、Word、MD文件","content":"工作中有个场景是chatgpt聊天对话记录下载支持PDF、Word、MD格式，于是有了本篇文章。\n实现思路对话中可能会用md格式的回答，且因为不能直接转成pdf或者word，所以这里通过方法转成md或者html代码，使用html格式转成pdf或者word。\n代码实现需要的nuget包\nhtml转pdfiTextSharpitextsharp.xmlworker\nhtml转wordFreeSpire.Doc\nmd转htmlMarkdig\n\n创建HtmlHelper帮助类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/// &lt;summary&gt;/// HTML帮助类/// &lt;/summary&gt;public class HtmlHelper&#123;\t/// &lt;summary&gt;\t/// 字体路径\t/// &lt;/summary&gt;\tprivate static string FontPath;\tpublic HtmlHelper(string fontPath)\t&#123;\t\tFontPath = fontPath;\t&#125;\tpublic HtmlHelper()\t&#123;\t&#125;\t//将html字符串转为pdf字节数组\tpublic byte[] ConvertHtmlTextToPDF(string htmlText)\t&#123;\t\tif (string.IsNullOrEmpty(htmlText))\t\t&#123;\t\t\treturn null;\t\t&#125;\t\ttry\t\t&#123;\t\t\tMemoryStream outputStream = new MemoryStream(); //要把PDF寫到哪個串流\t\t\tbyte[] data = Encoding.UTF8.GetBytes(htmlText); //字串轉成byte[]\t\t\tMemoryStream msInput = new MemoryStream(data);\t\t\tDocument doc = new Document(); //要寫PDF的文件，建構子沒填的話預設直式A4\t\t\tPdfWriter writer = PdfWriter.GetInstance(doc, outputStream);\t\t\t//指定文件預設開檔時的縮放為100%\t\t\tPdfDestination pdfDest = new PdfDestination(PdfDestination.XYZ, 0, doc.PageSize.Height, 1f);\t\t\t//開啟Document文件 \t\t\tdoc.Open();\t\t\t//使用XMLWorkerHelper把Html parse到PDF檔裡\t\t\tXMLWorkerHelper.GetInstance().ParseXHtml(writer, doc, msInput, null, Encoding.UTF8, new UnicodeFontFactory());\t\t\t//將pdfDest設定的資料寫到PDF檔\t\t\tPdfAction action = PdfAction.GotoLocalPage(1, pdfDest, writer);\t\t\twriter.SetOpenAction(action);\t\t\tdoc.Close();\t\t\tmsInput.Close();\t\t\toutputStream.Close();\t\t\treturn outputStream.ToArray();\t\t&#125;\t\tcatch (Exception ex)\t\t&#123;\t\t\tthrow new UserFriendlyException(&quot;转PDF时异常,请联系管理员！&quot;, ex);\t\t&#125;\t&#125;\t//将html字符串转为word字节数组\tpublic byte[] ConvertHtmlTextToWord(string htmlText)\t&#123;\t\tif (string.IsNullOrEmpty(htmlText))\t\t&#123;\t\t\treturn null;\t\t&#125;\t\ttry\t\t&#123;\t\t\tMemoryStream outputStream = new MemoryStream(); //要把Word寫到哪個串流\t\t\tbyte[] data = Encoding.UTF8.GetBytes(htmlText); //字串轉成byte[]\t\t\tMemoryStream  stream = new MemoryStream(data);\t\t\tSpire.Doc.Document doc = new Spire.Doc.Document(); //要寫Word的文件，建構子沒填的話預設直式A4\t\t\tdoc.LoadFromStream(stream, FileFormat.Html, XHTMLValidationType.None);\t\t\tdoc.SaveToStream(outputStream, FileFormat.Docx);\t\t\tdoc.Close();\t\t\treturn outputStream.ToArray();\t\t&#125;\t\tcatch (Exception ex)\t\t&#123;\t\t\tthrow new UserFriendlyException(&quot;转Word时异常,请联系管理员！&quot;, ex);\t\t&#125;\t&#125;\t//字体工厂\tpublic class UnicodeFontFactory : FontFactoryImp\t&#123;\t\tpublic override Font GetFont(string fontname, string encoding, bool embedded, float size, int style, BaseColor color,\t\t\tbool cached)\t\t&#123;\t\t\tBaseFont baseFont = BaseFont.CreateFont(FontPath, BaseFont.IDENTITY_H, BaseFont.EMBEDDED);\t\t\treturn new Font(baseFont, size, style, color);\t\t&#125;\t&#125;&#125;\n\n创建测试信息类12345public class Message&#123;\tpublic string Type &#123; get; set; &#125;\tpublic string Context &#123; get; set; &#125;&#125;\n\n通过控制器调用。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144public class FileController：Controller&#123;\tprivate readonly IHttpContextAccessor _httpContextAccessor;\tpublic FileController(IHttpContextAccessor httpContextAccessor）\t&#123;\t\t_httpContextAccessor=httpContextAccessor;\t&#125;\t\t/// &lt;summary&gt;\t\t/// 导出当前对话全部信息为Markdown\t\t/// &lt;/summary&gt;\t\t/// &lt;param name=&quot;messageId&quot;&gt;&lt;/param&gt;\t\t/// &lt;returns&gt;&lt;/returns&gt;\t\t[HttpGet]\t\t[DisableAuditing]\t\tpublic async Task&lt;IActionResult&gt; GenerateAllMarkdown()\t\t&#123;\t\t\tvar stringBuilder = await GenerateFile(&quot;md&quot;);\t\t\tbyte[] markdownBytes = Encoding.UTF8.GetBytes(stringBuilder);\t\t\tvar fileName = $&quot;文件名称-&#123;Clock.Now.ToString(&quot;yyyyMMddHHmmss&quot;)&#125;.md&quot;;\t\t\tvar contentType = &quot;text/markdown&quot;;\t\t\treturn File(markdownBytes, contentType, fileName);\t\t&#125;\t\t/// &lt;summary&gt;\t\t/// 导出当前对话全部信息为Word\t\t/// &lt;/summary&gt;\t\t/// &lt;param name=&quot;messageId&quot;&gt;&lt;/param&gt;\t\t/// &lt;returns&gt;&lt;/returns&gt;\t\t[HttpGet]\t\t[DisableAuditing]\t\tpublic async Task&lt;ActionResult&gt; GenerateAllWord()\t\t&#123;\t\t\tvar stringBuilder = await GenerateFile(&quot;html&quot;);\t\t\tHtmlHelper pdfHelper = new HtmlHelper();\t\t\tvar byteData = pdfHelper.ConvertHtmlTextToWord(stringBuilder);\t\t\tvar fileName = $&quot;文件名称-&#123;Clock.Now.ToString(&quot;yyyyMMddHHmmss&quot;)&#125;.docx&quot;;\t\t\tvar contentType = &quot;application/vnd.openxmlformats-officedocument.wordprocessingml.document&quot;;\t\t\treturn File(byteData, contentType, fileName);\t\t&#125;\t\t\t/// &lt;summary&gt;\t\t/// 导出当前对话全部信息为PDF\t\t/// &lt;/summary&gt;\t\t/// &lt;param name=&quot;chatId&quot;&gt;&lt;/param&gt;\t\t/// &lt;param name=&quot;chatUserId&quot;&gt;&lt;/param&gt;\t\t/// &lt;returns&gt;&lt;/returns&gt;\t\t/// &lt;exception cref=&quot;UserFriendlyException&quot;&gt;&lt;/exception&gt;\t\t[HttpGet]\t\t[DisableAuditing]\t\tpublic async Task&lt;ActionResult&gt; GeneratePDF()\t\t&#123;\t\t\t var stringBuilder = await GenerateFile(&quot;html&quot;);\t\t\tstring fontPath = Path.Combine(&quot;字体地址&quot;, &quot;Nsimsun.ttf&quot;);\t\t\tHtmlHelper pdfHelper = new HtmlHelper(fontPath);\t\t\tvar byteData = pdfHelper.ConvertHtmlTextToPDF(stringBuilder);//生成PDF\t\t\tvar fileName = $&quot;文件名称-&#123;Clock.Now.ToString(&quot;yyyyMMddHHmmss&quot;)&#125;.pdf&quot;;\t\t\tvar contentType = &quot;application/pdf&quot;;\t\t\treturn File(byteData, contentType, fileName);\t\t&#125;\tprivate async Task&lt;string&gt; GenerateFile(string type)\t&#123;\t\tvar title = &quot;我是标题&quot;;\t\tvar UserName = &quot;我是用户&quot;;\t\tvar Url = &quot;我是链接&quot;;\t\tList&lt;Message&gt; currentMessage = new List&lt;Message&gt;()\t\t&#123;\t\t\tnew Message()\t\t\t&#123;\t\t\t\tType =&quot;user&quot;,\t\t\t\tContext=&quot;你是谁&quot;\t\t\t&#125;，\t\t\tnew Message()\t\t\t&#123;\t\t\t\tType =&quot;bot&quot;,\t\t\t\tContext=&quot;hello，我是chatgpt&quot;\t\t\t&#125;\t\t\t//...\t\t&#125;;\t\t//信息查询操作。。。。\t\tstring stringBuilder = default;\t\tstring symbolA = &quot;&quot;;\t\tstring symbolB = &quot;&quot;;\t\tswitch (type)\t\t&#123;\t\t\tcase &quot;html&quot;:\t\t\t\tsymbolA = &quot;&lt;strong&gt;&quot;;\t\t\t\tsymbolB = &quot;&lt;/strong&gt;&quot;;\t\t\t\tbreak;\t\t\tcase &quot;md&quot;:\t\t\t\tsymbolA = &quot;**&quot;;\t\t\t\tsymbolB = &quot;**&quot;;\t\t\t\tbreak;\t\t&#125;\t\t//设置标题\t\tstringBuilder += $&quot;# &#123;title&#125; \\n&quot;;\t\tforeach (var item in allMessages)\t\t&#123;\t\t\tif (item.Type == &quot;bot&quot;)\t\t\t&#123;\t\t\t\tstringBuilder += $&quot;&#123;symbolA&#125; AI回答：&#123;symbolB&#125;  \\n&quot;;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tstringBuilder += $&quot;&#123;symbolA&#125; 用户提问：&#123;symbolB&#125;  \\n&quot;;\t\t\t&#125;\t\t\tstringBuilder += $&quot;&#123;item.Content&#125; \\n&quot;;\t\t\tstringBuilder += &quot;\\n&quot;;\t\t&#125;\t\tvar request = _httpContextAccessor.HttpContext.Request;\t\tstring fullUrl = $&quot;&#123;request.Scheme&#125;://&#123;request.Host&#125;&quot;;\t\tstringBuilder += $&quot;&gt; 编辑于 &#123;DateTime.Now&#125;\\n &quot; +\t\t\t$&quot;&gt;作者：&#123;UserName&#125; \\n &quot; +\t\t\t$&quot;&gt;链接：&#123;Url&#125;\\n &quot; +\t\t\t$&quot;&gt;来源：我是来源&quot;;\t\tif (type == &quot;html&quot;)\t\t&#123;\t\t\tstringBuilder = Markdown.ToHtml(stringBuilder);\t\t\tstringBuilder = stringBuilder.Replace(&quot;/n&quot;, &quot;&lt;br /&gt;&quot;);\t\t\tstringBuilder = stringBuilder.Replace(&quot;&lt;p&gt;&quot;, &quot;&quot;);\t\t\tstringBuilder = stringBuilder.Replace(&quot;&lt;/p&gt;&quot;, &quot;&lt;br /&gt;&quot;);\t\t\tstringBuilder = stringBuilder.Replace(&quot;AI回答：&quot;, &quot;&lt;br /&gt; AI回答：&quot;);\t\t\tstringBuilder = stringBuilder.Replace(&quot;用户提问：&quot;, &quot;&lt;br /&gt; 用户提问：&quot;);\t\t\tstringBuilder = stringBuilder.Replace(&quot;&lt;blockquote&gt;&quot;, &quot;&quot;);\t\t\tstringBuilder = stringBuilder.Replace(&quot;&lt;/blockquote&gt;&quot;, &quot;&quot;);\t\t\tstringBuilder = stringBuilder.Replace(&quot;编辑于：&quot;, &quot;&lt;br /&gt;&lt;br /&gt; 编辑于：&quot;);\t\t\tstringBuilder = stringBuilder.Replace(&quot;作者：&quot;, &quot;&lt;br /&gt; 作者：&quot;);\t\t\tstringBuilder = stringBuilder.Replace(&quot;链接：&quot;, &quot;&lt;br /&gt; 链接：&quot;);\t\t\tstringBuilder = stringBuilder.Replace(&quot;来源：&quot;, &quot;&lt;br /&gt; 来源：&quot;);\t\t\tstringBuilder = $&quot;\\r\\n&lt;!DOCTYPE html&gt;\\r\\n&lt;html&gt;\\r\\n&lt;head&gt;\\r\\n    &lt;meta charset=\\&quot;utf-8\\&quot; /&gt;\\r\\n    &lt;title&gt;&#123;currentChat.Name&#125;&lt;/title&gt;\\r\\n&lt;/head&gt;\\r\\n&lt;body&gt;\\r\\n&quot; + stringBuilder;\t\t\tstringBuilder += &quot;\\r\\n&lt;/body&gt;\\r\\n&lt;/html&gt;&quot;;\t\t&#125;\t\treturn stringBuilder;\t&#125;&#125;\n","slug":"c#实现对话记录转PDF、Word、MD文件","date":"2024-11-19T00:00:00.000Z","categories_index":".Net","tags_index":"c#,.Net","author_index":"FaceMan"},{"id":"09bfaf6dad899e5435cf142c3bc6c1cb","title":"Ubuntu在容器中通过bak文件还原数据库","content":"在容器中通过bak文件还原数据库1、测试环境需要迁移到另一台虚拟机上时\n\n可以使用nfs的方式获取备份文件，右上角搜索另一篇文章：NFS for CentOS\n使用scp命令从本机拷贝文件到目标服务器上，只需要提供目标服务器账号和密码。\n\n1scp /path filename root@目标服务器ip地址：/path\n\n\n2、要保证容器内部空间可以容纳bak文件大小的空间，使用df -h 查看，如果不够需要现在外面修改本机的容量配置，具体方法参考上文扩大虚拟硬盘容量，主要是扩大centos-root的容量。\n\n3、根据上述我们已经可以拿到文件了，现在我们需要将文件移动到docker镜像中\n1docker cp /mnt/nfs/gct_medPro_22_12_28_13_40.bak 1e057306ae58:/\n\n其中：\n\n&#x2F;mnt&#x2F;nfs&#x2F;gct_medPro_22_12_28_13_40.bak 是你在共享文件的所属位置\n1e057306ae58 是容器id 或则容器名字也可以\n\n进入容器内部，然后执行还原命令、\n123/opt/mssql-tools/bin/sqlcmd \\-S localhost -U sa -P &lt;your_password&gt; \\-Q &quot;RESTORE DATABASE &lt;new_database_name&gt; FROM DISK=&#x27;&lt;path-inside-container&gt;/&lt;backup-file-name&gt;.bak&#x27; WITH MOVE &#x27;&lt;logical_data_name&gt;&#x27; TO &#x27;&lt;new_data_file_path&gt;&#x27;, MOVE &#x27;&lt;logical_log_name&gt;&#x27; TO &#x27;&lt;new_log_file_path&gt;&#x27;, REPLACE, STATS=5&quot;\n\n其中 &lt;container-name&gt; 是容器的名称，&lt;your_password&gt; 是 SQL Server 的管理员密码，&lt;new_database_name&gt; 是你想要创建的新数据库的名称，&lt;path-inside-container&gt; 是之前复制备份文件的路径，&lt;backup-file-name&gt; 是备份文件的名称，&lt;logical_data_name&gt; 和 &lt;logical_log_name&gt; 是备份文件中的逻辑文件名，&lt;new_data_file_path&gt; 和 &lt;new_log_file_path&gt; 是你想要为新数据库指定的数据文件和日志文件的路径。\n例如：\n12345#我先查看还原文件位置root@1e057306ae58:/# lsbin  boot  dev  etc  gct_medPro_22_12_28_13_40.bak  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var然后执行root@1e057306ae58:/# /opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P &#x27;bb123456??&#x27; -Q &quot;RESTORE DATABASE gct_medPro FROM DISK=&#x27;/gct_medPro_22_12_28_13_40.bak&#x27; WITH MOVE &#x27;gct_medPro&#x27; TO &#x27;/var/opt/mssql/data/gct_medPro.mdf&#x27;, MOVE &#x27;gct_medPro_log&#x27; TO &#x27;/var/opt/mssql/data/gct_medPro.ldf&#x27;&quot;\n\n看到这个你就赢了。\n\n","slug":"在容器中通过bak文件还原数据库","date":"2024-11-19T00:00:00.000Z","categories_index":"DevOps","tags_index":"Docker,Linux,Ubuntu,数据库","author_index":"FaceMan"},{"id":"b41db14a99677b936cf320d0d9be73f1","title":"DockerSwarm环境搭建","content":"Swarm环境搭建系统规划\n环境准备创建服务器新建三台虚拟机\n\n\n\n节点\nIP\n系统\n配置\n存储\n服务\n\n\n\nmanager\n192.168.2.xx\nCentOS7.6\n8U16G\n100G\nredis,frp,mssql\n\n\nworker1\n192.168.2.xx\nCentOS7.6\n4U8G\n80G\napp\n\n\nworker2\n192.168.2.xx\nCentOS7.6\n4U8G\n80G\napp\n\n\n时间同步时间同步任务\n1234567891011121314yum install -y ntpcat &lt;&lt;EOF&gt;&gt;/var/spool/cron/root# 12点同步00 12 * * * /usr/sbin/ntpdate -u ntp1.aliyun.com &amp;&amp; /usr/sbin/hwclock -w# 23：59分执行删除59 23 * * *  docker image prune -afEOF##查看计划任务crontab -l##手动执行/usr/sbin/ntpdate -u ntp1.aliyun.com &amp;&amp; /usr/sbin/hwclock -w\n\nDocker安装Docker1curl -sSL http://mirror.dev.gct-china.com/docker/install.sh | sh\n\n启动docker\n12sudo systemctl start dockersudo systemctl enable docker\n\n防火墙\n\n\n\n\n\n\n\n\nError response from daemon: rpc error: code &#x3D; Unavailable desc &#x3D; connection error: desc &#x3D; “transport: Error while dialing dial tcp 192.168.2.61:2377: connect: no route to host”\n打开防火墙\n123456789101112# managerfirewall-cmd --zone=public --add-port=2377/tcp --permanent# 所有nodefirewall-cmd --zone=public --add-port=7946/tcp --permanentfirewall-cmd --zone=public --add-port=7946/udp --permanentfirewall-cmd --zone=public --add-port=4789/tcp --permanentfirewall-cmd --zone=public --add-port=4789/udp --permanent# 所有nodefirewall-cmd --reloadsystemctl restart docker\n\n要在 swarm 集群中使用使用路由网格，首先需要开启加入swarm集群的节点的以下端口：\n\n2377 ：主节点监听端口\n7946 ：容器网络发现\n4789 ：容器网络入口\n\nSwarm创建Swarm创建Swarm\n1docker swarm init --advertise-addr your_manager_ip\n\n\n12345678[root@manager ~]# docker swarm init --advertise-addr 192.168.2.61Swarm initialized: current node (rzds6oyb0bgvudzegpscmgiz3) is now a manager.To add a worker to this swarm, run the following command:    docker swarm join --token SWMTKN-1-51b7t8whxn8j6mdjt5perjmec9u8qguxq8tern9nill737pra2-ejc5nw5f90oz6xldcbmrl2ztu 192.168.2.61:2377To add a manager to this swarm, run &#x27;docker swarm join-token manager&#x27; and follow the instructions.\n\n加入Swarm1docker swarm join --token SWMTKN-1-51b7t8whxn8j6mdjt5perjmec9u8qguxq8tern9nill737pra2-ejc5nw5f90oz6xldcbmrl2ztu 192.168.2.61:2377\n\n\n查看节点12345[root@manager ~]# docker node lsID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSIONrzds6oyb0bgvudzegpscmgiz3 *   manager    Ready     Active         Leader           20.10.17rjj3fr5uazywwsfj6ok3f3fw3     worker1    Ready     Active                          20.10.176vkvdm3gcxip8htc6cfk8bm3n     worker2    Ready     Active                          20.10.17\n\n服务约束添加label\n12sudo docker node update --label-add role=env managersudo docker node update --label-add gct_medpro=gct_medpro zhuji\n\n\n给节点也加上\n1234[root@manager ~]# sudo docker node update --label-add role=app worker1worker1[root@manager ~]# sudo docker node update --label-add role=app worker2worker2\n","slug":"DockerSwarm环境搭建","date":"2024-11-18T16:00:00.000Z","categories_index":"DevOps","tags_index":"Docker","author_index":"FaceMan"},{"id":"fec2c7ee16664a58fd23e5c35dbd3596","title":"Ubuntu一键安装卸载docker和dockercompose","content":"在新建的服务器上，我们一般会用几条命令来下载安装docker和docker-compose，这里为了避免每次都去搜索安装命令，所以写成脚本，本文仅支持Ubuntu\\CentOS。\n一、docker是什么？Docker是一个开源的容器化平台，用于构建、部署和管理应用程序。它采用了轻量级的容器技术，可以在不同的操作系统上运行，并提供了一种将应用程序及其依赖项打包到可移植的容器中的方式。\n以下是Docker的一些重要特点和概念：\n\n容器化：Docker利用Linux内核的容器功能来隔离应用程序及其依赖项。每个容器都是一个独立的运行环境，具有自己的文件系统、进程空间和资源限制。容器可以快速启动、停止和迁移，而且相互之间彼此隔离，避免了应用程序之间的冲突和依赖问题。\n镜像：Docker使用镜像来构建容器。镜像是一个只读的模板，包含了应用程序运行所需的所有文件系统、库和依赖项。通过使用Dockerfile定义构建步骤，可以创建自定义的镜像。镜像可以从Docker Hub等镜像仓库中获取，也可以通过构建自己的镜像进行定制。\n容器注册表：Docker Hub是Docker官方的公共镜像注册表，提供了大量的基础镜像供用户使用。除此之外，还有其他的公共和私有镜像注册表，用户可以在其中存储和分享自己的镜像。\nDocker引擎：Docker引擎是运行和管理容器的核心组件。它包括一个守护进程（Docker daemon）和一个命令行客户端（Docker CLI）。守护进程负责构建、运行和管理容器，而命令行客户端提供了交互式的接口来与守护进程进行通信。\n编排和管理工具：Docker提供了一系列的编排和管理工具，用于简化多个容器的部署和管理。例如，Docker Compose允许通过一个YAML文件描述多个容器的关系和配置，并通过一条命令启动、停止和扩展整个应用程序的容器集群。\n跨平台支持：Docker可以在不同的操作系统上运行，包括Linux、Windows和MacOS等。对于Linux平台，Docker直接使用操作系统的容器功能；而对于Windows和MacOS，Docker使用一个轻量级的虚拟机（称为Docker Desktop）来提供容器化环境。\n生态系统：Docker拥有庞大的开发者社区和丰富的生态系统。社区提供了大量的文档、教程和示例代码，以及交流和支持的平台。此外，还有许多第三方工具和服务，如监控工具、CI&#x2F;CD集成等，与Docker集成，进一步扩展了其功能和用途。\n\n总结起来，Docker是一个强大的容器化平台，通过将应用程序及其依赖项打包到独立的容器中，提供了更加灵活、可移植和可扩展的应用部署和管理方式。它已经成为现代软件开发和运维的重要工具之一。\n二、docker compose是什么？Docker Compose是一个用于定义和管理多个Docker容器的工具。它允许您使用简单的YAML文件描述应用程序中的服务、网络、存储卷等配置，并通过一个命令行界面来启动、停止和管理这些容器。\n以下是Docker Compose的一些重要特点：\n\n声明式语法：Docker Compose使用声明式的YAML文件来描述应用程序的架构和配置。您可以在文件中定义每个服务的镜像、端口映射、环境变量、依赖关系等。这种声明式语法使得定义和管理复杂的容器集群变得简单且可维护。\n多容器应用管理：Docker Compose专注于管理多个相关的容器，以构建完整的应用程序堆栈。通过一次性的命令，您可以启动、停止、重启和销毁整个容器集群，而不需要手动处理每个容器。\n容器间连接和通信：使用Docker Compose，您可以轻松地为容器之间创建连接和网络。您可以定义容器之间的连接方式，使它们能够相互通信和访问。这在构建微服务架构或多层应用程序时非常有用。\n可伸缩性和负载均衡：Docker Compose允许您设置容器的伸缩策略，以根据应用程序的需要自动扩展或收缩容器。它还支持与负载均衡器集成，可以将流量分发到多个实例上，提高应用程序的性能和可靠性。\n环境隔离和测试：使用Docker Compose，您可以轻松地在开发和测试环境中复制生产环境的配置。您可以创建一个本地的容器化开发环境，确保应用程序在不同环境下的一致性，并减少由于环境差异引起的问题。\n可插拔的架构：Docker Compose是可插拔的，可以与其他工具和服务集成，以满足特定需求。例如，您可以与监控和日志记录工具集成，以监视和管理容器的性能和状态。\n\nCompose V1语法： Compose V1语法是较早版本的Compose语法，其文件名通常为docker-compose.yml。以下是一些Compose V1语法的特点：\n\nservices：使用services关键字定义要运行的服务。每个服务都有一个名称和一组配置选项。\nimage：指定要使用的镜像名称。\nports：定义要映射到主机上的容器端口。\nvolumes：指定要挂载到容器中的卷。\nlinks：定义与其他服务之间的连接。\nenvironment：设置容器中的环境变量。\ndepends_on：定义服务之间的依赖关系。\n\n以下是一个Compose V1语法的示例：\n1234567891011121314version: &#x27;2&#x27;services:  web:    image: nginx:latest    ports:      - 8080:80    volumes:      - ./html:/usr/share/nginx/html  db:    image: mysql:latest    environment:      - MYSQL_ROOT_PASSWORD=secret\n\nCompose V2语法： Compose V2语法是较新版本的Compose语法，其文件名通常为docker-compose.yaml或docker-compose.yml。以下是一些Compose V2语法的特点：\nservices：与Compose V1相同，使用services关键字定义要运行的服务。image、ports、volumes、environment等选项与Compose V1相同。引入了新的配置选项，如networks、configs和secrets，用于更灵活地定义网络、配置文件和机密信息。以下是一个Compose V2语法的示例：\n123456789101112131415161718version: &#x27;3&#x27;services:  web:    image: nginx:latest    ports:      - 8080:80    volumes:      - ./html:/usr/share/nginx/html  db:    image: mysql:latest    environment:      - MYSQL_ROOT_PASSWORD=secretnetworks:  app-net:    driver: bridge\n\n除了以上介绍的不同之外，Compose V2语法还带来了一些其他改进和功能增强，例如支持多个文件的扩展性，可选项的验证和默认值等。\n需要注意的是，在使用Docker Compose时，要根据您所使用的Compose版本选择正确的语法，并确保在编写Compose文件时遵循该版本的语法规范。\n三、Ubuntu-24.04版本安装最新用了最新的Ubuntu-24.04系统，发现以前的安装脚本会报错，不确定是不是24.04开始改变的，24.04只需要执行：snap install docker 就可以安装了。其他版本你也可以先试试用snap install docker安装，不行再试下面的方法。\n四、旧版本安装步骤1、Ubuntu 安装脚本代码如下（示例）：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/bin/bash# 卸载当前版本echo &quot;卸载当前版本.....&quot;sudo apt-get remove docker docker-engine docker.io containerd runcy# 设置apt源echo &quot;设置apt源.....&quot;sudo apt-get update# 安装基础依赖echo &quot;安装基础依赖.....&quot;sudo apt-get install -y \\    ca-certificates \\    curl \\    gnupg# 启用docker官方的源echo &quot;启用docker官方的源.....&quot;echo \\  &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\  $(. /etc/os-release &amp;&amp; echo $VERSION_CODENAME) stable&quot; | \\  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null# 添加docker官方的GPG Keyecho &quot;添加docker官方的GPG Key.....&quot;sudo mkdir -m 0755 -p /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg# 更新软件源## 更新密钥权限，可选 sudo chmod a+r /etc/apt/keyrings/docker.gpgecho &quot;更新软件源.....&quot;sudo apt-get updateecho &quot;安装最新版本或特定版本(Y（最新）/N（特定）)?&quot;read answerif [ &quot;$answer&quot; == &quot;Y&quot; -o &quot;$answer&quot; == &quot;y&quot; ]; then    echo &quot;安装最新版本&quot;    # 安装最新版本    sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-pluginelif [ &quot;$answer&quot; == &quot;N&quot; -o &quot;$answer&quot; == &quot;n&quot; ]; then    echo &quot;查询版本&quot;    ## 查询版本    apt-cache madison docker-ce | awk &#x27;&#123; print $3 &#125;&#x27;    echo &quot;请指定版本：    例如5:20.10.23~3-0~ubuntu-bionic、5:20.10.23~3-0~ubuntu-focal、5:20.10.23~3-0~ubuntu-jammy&quot;    read VERSION_STRING    # 安装特定版本    # ## 安装特定版本 ubuntu 18.04    # VERSION_STRING=5:20.10.23~3-0~ubuntu-bionic    # ## 安装特定版本 ubuntu 20.04    # VERSION_STRING=5:20.10.23~3-0~ubuntu-focal    # ## 安装特定版本 ubuntu 22.04    # VERSION_STRING=5:20.10.23~3-0~ubuntu-jammy    ## 安装    sudo apt-get install -y docker-ce=$VERSION_STRING docker-ce-cli=$VERSION_STRING containerd.io docker-compose-pluginelse    echo &quot;无效的输入&quot;fi\n\n2.生成脚本将上述命令保存为一个脚本文件（例如script.sh），并添加执行权限。您可以在终端中使用以下命令来执行该脚本：\n12chmod +x script.sh./script.sh\n\n3.启动和验证12345678910111213# 查看dockerdocker -v# 老版本docker compose命令为docker-compose -v# 新版本docker compose命令为docker compose version# 查看docker服务是否启动$ systemctl status docker# 若未启动，则启动docker服务$ sudo systemctl start docker# 验证hello world$ sudo docker run hello-world\n\n五、卸载步骤1.Ubuntu卸载脚本123456789101112131415161718192021222324252627282930# 卸载旧版本的Dockeryum remove docker \\                  docker-client \\                  docker-client-latest \\                  docker-common \\                  docker-latest \\                  docker-latest-logrotate \\                  docker-logrotate \\                  docker-selinux \\                  docker-engine-selinux \\                  docker-engine \\                  docker-cerm -rf /etc/dockerrm -rf /run/dockerrm -rf /var/lib/dockershim#删除docker的镜像文件rm -rf /var/lib/dockerps -ef|grep docker|grep -v grep|xargs kill -s 9#卸载docker相关包yum remove docker-*yum remove docker-ce-cli-*yum remove docker-scan-plugin*# 删除旧版docker-composerm -rf /usr/local/bin/docker-composerm -rf /usr/bin/docker-compose\n\n2.保存文件后设置执行权限1chmod +777  docker-uninstall.sh\n\n3.运行文件1sh  docker-uninstall.sh\n\n4.验证是否删除成功12docker -vdocker-compose -v\n\n六、CentOS安装脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#!/bin/bash\t# 卸载当前版本\techo &quot;卸载当前版本.....&quot;\tsudo yum remove docker-ce docker-ce-cli containerd.io\t# 设置yum源\techo &quot;设置yum源.....&quot;\tsudo yum install -y yum-utils\tsudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\t# 安装基础依赖\techo &quot;安装基础依赖.....&quot;\tsudo yum install -y \\\t    yum-plugin-copr \\\t    device-mapper-persistent-data \\\t    lvm2 \\\t    git \\\t    bash-completion \\\t    bash-completion-extras \\\t    iptables \\\t    policycoreutils-python \\\t    selinux-policy-base \\\t    selinux-policy-targeted \\\t    audit \\\t    libseccomp-devel \\\t    python3-pip \\\t    python3-setuptools \\\t    python3-wheel\t# 更新软件源\techo &quot;更新软件源.....&quot;\tsudo yum update -y\techo &quot;安装最新版本或特定版本(Y（最新）/N（特定）)?&quot;\tread answer\tif [ &quot;$answer&quot; == &quot;Y&quot; -o &quot;$answer&quot; == &quot;y&quot; ]; then\t    echo &quot;安装最新版本&quot;\t    # 安装最新版本\t    sudo yum install -y docker-ce docker-ce-cli containerd.io\telif [ &quot;$answer&quot; == &quot;N&quot; -o &quot;$answer&quot; == &quot;n&quot; ]; then\t    echo &quot;查询版本&quot;\t    ## 查询版本\t    yum list docker-ce --showduplicates | grep -i &quot;docker-ce&quot;\t    echo &quot;请指定版本：\t    例如3:20.10.11-3.el7、3:20.10.11-3.el8&quot;\t    read VERSION_STRING\t    # 安装特定版本\t    ## 安装特定版本 centos 7\t    # VERSION_STRING=3:20.10.11-3.el7\t    ## 安装特定版本 centos 8\t    # VERSION_STRING=3:20.10.11-3.el8\t    ## 安装\t    sudo yum install -y docker-ce-$VERSION_STRING docker-ce-cli-$VERSION_STRING containerd.io\telse\t    echo &quot;无效的输入&quot;\tfi\t# 启动Docker服务\techo &quot;启动Docker服务.....&quot;\tsudo systemctl start docker\t# 设置Docker开机自启\techo &quot;设置Docker开机自启.....&quot;\tsudo systemctl enable docker\t# 配置Docker加速器\techo &quot;配置Docker加速器.....&quot;\techo &#x27;&#123;\t  &quot;registry-mirrors&quot;: [&quot;https://your_mirror_url&quot;]\t&#125;&#x27; | sudo tee /etc/docker/daemon.json\t# 重启Docker服务\techo &quot;重启Docker服务.....&quot;\tsudo systemctl daemon-reload\tsudo systemctl restart docker\techo &quot;Docker安装完成&quot;\n\n卸载脚本123456789101112131415161718192021222324#!/bin/bash# 停止和删除所有Docker容器echo &quot;停止和删除所有Docker容器.....&quot;sudo docker stop $(sudo docker ps -aq)sudo docker rm $(sudo docker ps -aq)# 卸载Docker服务echo &quot;卸载Docker服务.....&quot;sudo yum remove -y docker-ce docker-ce-cli containerd.io# 删除Docker相关文件和目录echo &quot;删除Docker相关文件和目录.....&quot;sudo rm -rf /var/lib/dockersudo rm -rf /etc/docker# 删除Docker用户组echo &quot;删除Docker用户组.....&quot;sudo groupdel docker# 删除Docker存储库echo &quot;删除Docker存储库.....&quot;sudo rm -f /etc/yum.repos.d/docker-ce.repoecho &quot;Docker已成功卸载&quot;\n\n总结我们可以通过用户输入指令来安装不同版本的docker和docker compose，也可以一键卸载，使用脚本省心又快捷。\n","slug":"Ubuntu一键安装卸载docker","date":"2024-11-18T16:00:00.000Z","categories_index":"DevOps","tags_index":"","author_index":"FaceMan"}]