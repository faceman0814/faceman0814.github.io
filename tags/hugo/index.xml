<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hugo on FaceMan&#39;s Blog</title>
    <link>https://blog.faceman.cn/tags/hugo/</link>
    <description>Recent content in Hugo on FaceMan&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 08 Nov 2024 17:36:52 +0800</lastBuildDate>
    <atom:link href="https://blog.faceman.cn/tags/hugo/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>使用Hugo搭建个人博客</title>
      <link>https://blog.faceman.cn/post/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Fri, 08 Nov 2024 17:36:52 +0800</pubDate>
      <guid>https://blog.faceman.cn/post/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
      <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;&#xA;&lt;p&gt;先来说说写这篇博客的缘由&lt;/p&gt;&#xA;&lt;p&gt;一个程序员最好的门面是啥？除了github拥有star数高的开源项目之外当然是个人博客，无论是技术积累还是找工作，有一个属于自己的个人博客无疑是加分项，现在github上有各种开源的博客系统，优点是功能很多，但都有个问题就是大，我之前用Java的oneblog项目部署了一个博客，但由于我是买的阿里云2核2g服务器，部署上去之后由于太大系统崩了，我重启了3次才在docker重启之前关掉，就很尴尬。后面想了个办法是部署到自己的电脑的虚拟机上，然后通过frp+nginx映射出去，但问题又来了，我是笔记本没有办法保证像服务器一样一直运行着，于是，我摆烂了。后面刷B站的时候看到了数字游牧人的一个视频，了解到了hugo这个东西，于是我琢磨了一天弄了个博客出来，踩了一些坑，所以有了今天这篇文章，补充完整给新手小白们避坑。&lt;/p&gt;&#xA;&lt;h1 id=&#34;必要条件&#34;&gt;必要条件&lt;/h1&gt;&#xA;&lt;p&gt;安装和部署网上教程很多，我这里就不多赘述了。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/7265268463256616972?from=search-suggest&#34;&gt;在github.io安装部署个人博客hugo&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;tips&#34;&gt;Tips&lt;/h1&gt;&#xA;&lt;h2 id=&#34;1不翻墙访问&#34;&gt;1.不翻墙访问&lt;/h2&gt;&#xA;&lt;p&gt;前提：需要有一个自己的域名，如果想以https访问还需要配置证书。&lt;/p&gt;&#xA;&lt;p&gt;总所周知，github是需要翻墙才能访问，如果我们想不翻墙访问博客可以到github项目的Page页设置自域名（Custom domain）和nginx代理。&lt;/p&gt;&#xA;&lt;h3 id=&#34;1配置nginx代理&#34;&gt;1.配置nginx代理&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;error_log /var/log/nginx/error.log;&#xA;&#xA;    server {&#xA;        listen 80;&#xA;        listen 443 ssl;&#xA;        server_name blog.faceman.cn; # 你的域名&#xA;        ssl_protocols TLSv1.2 TLSv1.1 TLSv1; &#xA;  &#xA;        ssl_certificate      /domains/fullchain.pem; # 证书位置&#xA;        ssl_certificate_key  /domains/key.key; # 证书位置&#xA;        ssl_prefer_server_ciphers on; &#xA;        ssl_session_timeout  5m;&#xA;        if ($server_port = 80) {&#xA;        rewrite ^(.*)$ https://$host$1 permanent;&#xA;        }&#xA;        location / {&#xA;            proxy_pass https://faceman0814.github.io; # 映射地址&#xA;            proxy_set_header Host $host;&#xA;            proxy_set_header X-Real-IP $remote_addr;&#xA;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&#xA;            root /home/web/;&#xA;            index index.php;&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重启nginx即可&lt;/p&gt;&#xA;&lt;h3 id=&#34;2设置自域名&#34;&gt;2.设置自域名&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img alt=&#34;1731135427227&#34; src=&#34;https://blog.faceman.cn/images/article/1731135427227.png&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;2部署脚本&#34;&gt;2.部署脚本&lt;/h2&gt;&#xA;&lt;p&gt;为了简化部署流程，我写了一套Windows版本的脚本分享给大家&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;param(&#xA;    [string]$commitMessage = &amp;#34;博客更新&amp;#34;&#xA;)&#xA;&#xA;# 输出部署更新信息&#xA;Write-Host &amp;#34;正在部署到GitHub...&amp;#34; -ForegroundColor Green&#xA;&#xA;# 构建项目&#xA;&amp;amp; hugo&#xA;&#xA;# 进入Public文件夹&#xA;Set-Location public&#xA;&#xA;# 将更改添加到git&#xA;git add .&#xA;&#xA;# 提交更改&#xA;Write-Host $commitMessage -ForegroundColor Green&#xA;git commit -m $commitMessage&#xA;&#xA;# 拉取最新的远程仓库更改以避免冲突&#xA;git pull origin main&#xA;&#xA;# 推送源和构建仓库&#xA;git push origin main&#xA;&#xA;# 返回到项目根目录&#xA;Set-Location ..&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根目录下面保存为deploy.ps1(powershell脚本格式)&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//在根目录下运行&#xA;/deploy.ps1 &amp;#34;提交内容&amp;#34; //默认提交内容为博客更新&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我用的ananke主题有些小问题，比如：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;github地址生成的时候会有些乱码导致跳转404&lt;/li&gt;&#xA;&lt;li&gt;静态图片部署的时候会被损坏&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;我在脚本处理，如果你们没有这个问题可以略过。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;param(&#xA;    [string]$commitMessage = &amp;#34;博客更新&amp;#34;&#xA;)&#xA;&#xA;# 输出部署更新信息&#xA;Write-Host &amp;#34;正在部署到GitHub...&amp;#34; -ForegroundColor Green&#xA;&#xA;# 构建项目&#xA;&amp;amp; hugo&#xA;&#xA;# 进入Public文件夹&#xA;Set-Location public&#xA;&#xA;# 扫描所有文件并替换指定字符串&#xA;$replacements = @{&#xA;    &amp;#34;https://github.com/faceman0814&amp;#34; = &amp;#34;https://github.com/faceman0814&amp;#34;;&#xA;}&#xA;&#xA;# 扫描所有文件并替换指定字符串&#xA;Get-ChildItem -Recurse | Where-Object { !$_.PSIsContainer } | ForEach-Object {&#xA;    $content = Get-Content $_.FullName -Raw&#xA;    foreach ($oldText in $replacements.Keys) {&#xA;        $newText = $replacements[$oldText]&#xA;        $content = $content -replace [regex]::Escape($oldText), $newText&#xA;    }&#xA;    Set-Content $_.FullName -Value $content&#xA;}&#xA;&#xA;# 复制 images 文件夹，使用相对路径回退到根目录再访问static/images&#xA;$sourcePath = &amp;#34;..\static\images&amp;#34;&#xA;$destinationPath = &amp;#34;.\images&amp;#34;&#xA;Copy-Item -Path $sourcePath\* -Destination $destinationPath -Force -Recurse&#xA;&#xA;&#xA;# 将更改添加到git&#xA;git add .&#xA;&#xA;# 提交更改&#xA;Write-Host $commitMessage -ForegroundColor Green&#xA;git commit -m $commitMessage&#xA;&#xA;# 拉取最新的远程仓库更改以避免冲突&#xA;git pull origin main&#xA;&#xA;# 推送源和构建仓库&#xA;git push origin main&#xA;&#xA;# 返回到项目根目录&#xA;Set-Location ..&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;页脚加运行时间&#34;&gt;页脚加运行时间&lt;/h2&gt;&#xA;&lt;p&gt;在页脚加入代码&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;div class=&amp;#34;footer-container&amp;#34;&amp;gt;&#xA;      &amp;lt;span id=&amp;#34;sitetime&amp;#34;&amp;gt;载入运行时间...&amp;lt;/span&amp;gt;&#xA; &amp;lt;/div&amp;gt;&#xA;&#xA;&amp;lt;script&amp;gt;&#xA;  function siteTime() {&#xA;      var seconds = 1000;&#xA;      var minutes = seconds * 60;&#xA;      var hours = minutes * 60;&#xA;      var days = hours * 24;&#xA;      var years = days * 365;&#xA;      var today = new Date();&#xA;      var startYear = 2024;&#xA;      var startMonth = 11;&#xA;      var startDate = 8;&#xA;      var startHour = 14;&#xA;      var startMinute = 15;&#xA;      var startSecond = 11;&#xA;      var todayYear = today.getFullYear();&#xA;      var todayMonth = today.getMonth() + 1;&#xA;      var todayDate = today.getDate();&#xA;      var todayHour = today.getHours();&#xA;      var todayMinute = today.getMinutes();&#xA;      var todaySecond = today.getSeconds();&#xA;      var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);&#xA;      var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);&#xA;      var diff = t2 - t1;&#xA;      var diffYears = Math.floor(diff / years);&#xA;      var diffDays = Math.floor((diff / days) - diffYears * 365);&#xA;      var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);&#xA;      var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /&#xA;          minutes);&#xA;      var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -&#xA;          diffMinutes * minutes) / seconds);&#xA;      if (startYear == todayYear) {&#xA;          //document.getElementById(&amp;#34;year&amp;#34;).innerHTML = todayYear;&#xA;          document.getElementById(&amp;#34;sitetime&amp;#34;).innerHTML = &amp;#34;博客已运行 &amp;#34; + diffDays + &amp;#34; 天 &amp;#34; + diffHours +&#xA;              &amp;#34; 小时 &amp;#34; + diffMinutes + &amp;#34; 分钟 &amp;#34; + diffSeconds + &amp;#34; 秒&amp;#34;;&#xA;      } else {&#xA;          //document.getElementById(&amp;#34;year&amp;#34;).innerHTML = startYear + &amp;#34; - &amp;#34; + todayYear;&#xA;          document.getElementById(&amp;#34;sitetime&amp;#34;).innerHTML = &amp;#34;博客已运行 &amp;#34; + diffYears + &amp;#34; 年 &amp;#34; + diffDays +&#xA;              &amp;#34; 天 &amp;#34; + diffHours + &amp;#34; 小时 &amp;#34; + diffMinutes + &amp;#34; 分钟 &amp;#34; + diffSeconds + &amp;#34; 秒&amp;#34;;&#xA;      }&#xA;  }&#xA;  setInterval(siteTime, 1000);&#xA;&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;添加访问量计数工具&#34;&gt;添加访问量计数工具&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;script async src=&amp;#34;https://busuanzi.icodeq.com/busuanzi.pure.mini.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;&#xA;&#xA;本文总阅读量 &amp;lt;span id=&amp;#34;busuanzi_value_page_pv&amp;#34;&amp;gt;&amp;lt;/span&amp;gt; 次&#xA;&#xA;本站总访问量 &amp;lt;span id=&amp;#34;busuanzi_value_site_pv&amp;#34;&amp;gt;&amp;lt;/span&amp;gt; 次&#xA;&#xA;本站总访客数 &amp;lt;span id=&amp;#34;busuanzi_value_site_uv&amp;#34;&amp;gt;&amp;lt;/span&amp;gt; 人&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;遇到的一些坑&#34;&gt;遇到的一些坑&lt;/h2&gt;&#xA;&lt;h3 id=&#34;中文博客内容截断过长&#34;&gt;中文博客内容截断过长&lt;/h3&gt;&#xA;&lt;p&gt;默认情况下，Hugo 可能会根据单词边界来截断摘要，这在处理英文时比较合适，但对于中文等没有明显空格分隔的语言则不太适用。就可能会导致摘要部分过长，导致观感不好，面对这种情况有两个解决方案。&lt;/p&gt;&#xA;&lt;h4 id=&#34;方案-1自定义-summary-分隔符&#34;&gt;方案 1：自定义 Summary 分隔符&lt;/h4&gt;&#xA;&lt;p&gt;你可以在文章中手动定义一个分隔符来指示摘要结束的位置。例如，在 Markdown 文件中使用`&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

